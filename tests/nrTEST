#!/bin/sh
#
# test script for the nr program
#
#


PATH=$HOME/bin:$PATH
NR=nr
PYTHON=python3
TMPFILE=/tmp/$$
DELETE_THESE=""
EXITSTATUS=0

QUICK=no
DEVTEST=no
NRTEST=./nrTEST      # only used in DEVTEST case

#
# OPTIONS
#    -Q skips some of the slower tests ("quick")
#    -X allows override of nr and python via environment variables (debug/test).
#    -D is for development testing and recursively invokes itself to test
#       python and python3 using the local development tree (yeehah!)
#
# Note the option parsing is hokey and doesn't allow e.g., -XQ use -X -Q
#

while [ $# -gt 0 ]
do
  case "x$1" in
    x-Q)
      QUICK=yes
      shift
      ;;

    x-X)
      if [ "x$PYX" != "x" ]; then PYTHON="$PYX"; fi
      if [ "x$NRX" != "x" ]; then NR="$NRX"; fi
      echo "Using \"$PYTHON\" for python interpreter"
      echo "Using \"$NR\" for the nr command program"
      if [ "x$NRTX" != "x" -a "x$NRTX" != "x$NRTEST" ]
      then
          echo " ... and NRTEST is overridden to $NRTX"
          NRTEST="$NRTX"
      fi
      shift
      ;;

    x-D)
      DEVTEST=yes
      shift
      ;;

  esac
done

if [ "$DEVTEST" = "yes" ]
then
    echo DEVELOPMENT TESTING MODE

    if [ ! -x $NRTEST ]; then echo "no $NRTEST - aborting"; exit 1; fi
    QK=""
    if [ "$QUICK" = "yes" ]; then QK="-Q"; fi

    NRPY=../shell-cmd/nr.py

    echo ' - - - - TESTING PYTHON 2 - - - -'

    PYX=python NRX="python $NRPY" NRTX="$NRTEST" PYTHONPATH=.. $NRTEST -X $QK
    if [ $? -ne 0 ]; then echo "python v2 failed"; exit 1; fi

    echo ' - - - - TESTING PYTHON 3 - - - -'

    PYX=python3 NRX="python3 $NRPY" NRTX="$NRTEST" PYTHONPATH=.. $NRTEST -X $QK
    if [ $? -ne 0 ]; then echo "python3 failed"; exit 1; fi

    exit 0
fi




# silly little function to add numbers using python
# because sometimes (believe it or not) bc isn't there
# We KNOW python is here
#
# result in RESULT
add() {
  RESULT=`$PYTHON -c "print( $1 + $2 )"`
}

# for bailing out with a message
failout() {
    DIE=yes
    if [ "x$1" = "xCONTINUE" ]; then DIE=no; shift; fi
    echo "FAILED:::: $*"
    if [ "$DIE" = "yes" ]; then exit 1; fi
}


#
# idiomatic way to do something with $NR, log it, check for status, etc.
# If $1 looks like "EXIT:N" then the expected result is $? = N
#
# Will exit 1 if fails, otherwise RESULT is set to the result.
#
doNR() {
  GOODSTATUS=0
  case "x$1" in
    xEXIT:*)
      GOODSTATUS=`echo $1 | sed -e 's/^.*://'`
      shift
      ;;
  esac

  echo "TESTING::: $NR $*"
  $NR "$@" > $TMPFILE
  STATUS=$?
  if [ $STATUS != $GOODSTATUS ]; then failout "... $NR exit status $STATUS"; fi
  RESULT=`cat $TMPFILE`
}

#
# idiomatic way to doNR and test result for a specific result
# Expected result is $1 ; Detail info for unexpected is $2;
# Remaining arguments go to doNR
#
verifyNR() {
  EXPECTED=$1
  ERRMSG=$2
  shift 2

  doNR "$@"
  if [ "x$RESULT" != "x$EXPECTED" ]
  then
    failout "${ERRMSG}: Expected \"$EXPECTED\" Got \"$RESULT\""
  fi
}

#
# Just a way to put an info into the output stream, properly formatted
#
infomsg() {
  echo "INFO:::::: $*"
}

# variant for things skipped via -Q
quickmsg() {
  echo "QUICK::::: $*"
}

# utility function to parse a JSON object and return (via RESULT) a field
# JSON object in $1
# desired field key in $2
parsejson() {
  JPGM="import json; d = json.loads('"$1"'); print(d['"$2"'])"
  RESULT=`$PYTHON -c "$JPGM"`
}

#
# utility function to...
#   Take the JSON object in $1 which should be NR output
#   Go into the Results top level field
#   take the $2'th element of the Results array
#   take the result element of that
#   return the $3 element of that
#
# typical use if you expected one JSON result from NR would be
#
#    parseNRJSON "$J" 0 description
#
# where J is the NR output and, for example, description is the field you want
#
parseNRJSON() {
  JPGM="import json
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('j')
args = parser.parse_args()

d = json.loads(args.j)
print(d['Results']["$2"]['result']['"$3"'])
"

  RESULT=`$PYTHON -c "$JPGM" "$1"`
}




#
# Test the -k function first of all
#

if [ "x$NUMEROUSAPIKEY" = x ]
then
  NUMEROUSAPIKEY=$HOME/.myCred export NUMEROUSAPIKEY
fi

echo "Version under test:" `$NR -V`

doNR -k
APIKEY="$RESULT"

#
# See if we can successfully connect
#
doNR -q

#
# Create a test metric to bang on
#
M=nrTEST$$
MVAL=999
Mparams="{ \"private\" : true, \"value\" : $MVAL }"


doNR -wM +$M "$Mparams"
METRIC=$RESULT

infomsg "created $METRIC"

DELETE_THESE="$DELETE_THESE $METRIC"

# see if it got created with the correct privacy and value
verifyNR $MVAL "Wrong initial value" $METRIC
verifyNR True "Wrong private setting" $METRIC[private]

# see if we can read it with the other allowed metric ID forms
doNR $METRIC'[self]'
verifyNR $MVAL "Reading via $RESULT" $RESULT

doNR $METRIC'[web]'
verifyNR $MVAL "Reading via $RESULT" $RESULT

# write a value
verifyNR $$ "wrong write result" -w $METRIC $$

# write same value with -y and expect exit 1
verifyNR "" "-wy" "EXIT:1" -wyq $METRIC $$

# interject a comment
C='this be the naked comment'
doNR -wIq $METRIC "$C"
verifyNR "$C" "Comment readback" -I --limit 1 "$METRIC[commentBody]"

# AGAIN write the same value with -y, should "fail"
infomsg "-wyq test AGAIN"
verifyNR "" "-wy" "EXIT:1" -wyq $METRIC $$

# increment by 1
doNR $METRIC
add $RESULT 1
NEWVAL=$RESULT
verifyNR $NEWVAL "Added 1" -w+ $METRIC 1

# now writing the original test value with -y should succeed
verifyNR $$ "Rewriting $$" -wy $METRIC $$

# see if the add really works correctly...
verifyNR 17 "Writing 17" -w $METRIC 17
verifyNR 20 "Adding 3" -w+ $METRIC 3
verifyNR -1 "Subtracting 21" -w+ $METRIC -21
verifyNR -1 "Read back" $METRIC

# try making an error entry
ErrString="This is the error info"
ErrInfo="{ \"kind\": \"error\", \"commentBody\": \"$ErrString\" }"

verifyNR "" "Setting an error" -wIq $METRIC "$ErrInfo"

# see if that error is actually there now
verifyNR "error" "Reading back the [kind]" -I --limit 1 "$METRIC[kind]"

# and check the text
verifyNR "$ErrString" "Readback errstring" -I --limit 1 "$METRIC[commentBody]"

# test updating a metric's description
Desc="This is the metric's porpoise in life"
Units="blivets"
updateJSON="{ \"description\": \"$Desc\", \"units\" : \"$Units\" }"

doNR -wMq $METRIC "$updateJSON"
verifyNR "$Desc" "[description]" "${METRIC}[description]"
verifyNR "$Units" "[units]" "${METRIC}[units]"

# once more to check read/mod/write feature
Desc="something else"
updateJSON="{ \"description\": \"$Desc\" }"
doNR -wMq $METRIC "$updateJSON"
verifyNR "$Desc" "[description(2)]" "${METRIC}[description]"
verifyNR "$Units" "[units(2)]" "${METRIC}[units]"

# some JSON option testing (testing the nr command itself)
V=123
doNR -wq $METRIC $V
doNR -j $METRIC $METRIC $METRIC
J="$RESULT"
for i in 0 1 2
do
  parseNRJSON "$J" $i value
  if [ "x$RESULT" != "x$V" ]
  then
    failout "Got $RESULT expected $V for element $i"
  fi
done

Desc="{ a bunch of stuff in unbalanced] braces {}"
updateJSON="{ \"description\": \"$Desc\" }"

doNR -wMq $METRIC "$updateJSON"
doNR -j $METRIC
J="$RESULT"
parseNRJSON "$J" 0 description
if [ "x$RESULT" != "x$Desc" ]
then
  failout "Got $RESULT expected $Desc"
fi

# make a "timer" metric to bang on
TMR=nrTMRTEST$$
TMRparams='{ "private" : true, "kind" : "timer" }'

doNR -wM +$TMR "$TMRparams"
TMETRIC=$RESULT

echo "CREATED::: $TMETRIC"

DELETE_THESE="$DELETE_THESE $TMETRIC"

# set it to a particular date
doNR -wq $TMETRIC "EPOCHTIME: 1/15/2011"   # nephew's birthday :)

# I don't really have a good way to test that the date got set correctly.
# Well, I could, but I'm too lazy to write all that shell code. So we're
# just happy here if the date conversion above didn't blow up. Declare victory.

# make another "virgin" metric to bang on
VGM=nrVGTEST$$
VGMparams='{ "private" : true }'

doNR -wM +$VGM "$VGMparams"
VGMETRIC=$RESULT

echo "CREATED::: $VGMETRIC"

DELETE_THESE="$DELETE_THESE $VGMETRIC"

# make sure getting an empty collection of various flavors works
for ARG in E I S
do
  verifyNR "" "-${ARG}" -${ARG} $VGMETRIC
done


# fire off 30 add +1 operations in parallel.
# They are supposed to operate atomically (they didn't in the past
# but that was a server bug and is now fixed)

echo "TESTING::: 30 x $NR -w+q $METRIC 1 -- in parallel"
doNR -wq $METRIC 0
for i in 0 1 2 3 4 5 6 7 8 9
do
  # we actually do 10x invocations of NR that each do three updates
  # this seems to increase *effective* parallism at the server though
  # obviously a lot depends on timing and speed of the client machine
  $NR -w+q $METRIC 1 $METRIC 1 $METRIC 1 &
done

wait

verifyNR 30 "Atomicity failed" $METRIC

# fire off 50 "onlyIfChanged" operations in parallel
# only one of them should change the variable, the rest should be "NoChange"
#
# XXX the server does implement these atomically, so I've never been
#     able to verify whether this would expose any atomicity error.

# another version of the numerous server atomicity test
yatom() {

    #
    # fire off 50 "onlyIfChanged" operations in parallel
    # only one of them should change it, the rest should be "NoChange"
    #

    # note the use of files to attempt to synchronize all of these.
    # it can take a while for them all to get forked and situated


    TPGM="import argparse
import time
import numerous

nr = numerous.Numerous(apiKey=\"$APIKEY\")
metric = nr.metric(\"$METRIC\")

# force libs to load
try:
  ignored = metric.write(metric.read(), onlyIf=True)
except numerous.NumerousMetricConflictError:
  pass


parser = argparse.ArgumentParser()
parser.add_argument('readyfile', nargs=1)
parser.add_argument('gofile1', nargs=1)
parser.add_argument('gofile2', nargs=1)

args = parser.parse_args()

# tell the world we ready
f = open(args.readyfile[0],'w+')

# the first loop doesn't fully busy-wait so everyone can get started
while True:
  try:
    g = open(args.gofile1[0])
    break
  except IOError:
    time.sleep(2)

# so after you make the gofile1 you should wait more than 2 seconds
# (my test program waits 15 seconds) then make gofile2
while True:
  try:
    g = open(args.gofile2[0])
    break
  except IOError:
    pass

# and off we go!!!
r = 'Changed'
try:
  metric.write(100, onlyIf=True)
except numerous.NumerousMetricConflictError:
  r = 'NoChange'
print (r)
"

    NTIMES=50    # XXX you have to update the for loops to match

    doNR -wq $METRIC 0

    # get the ID of that event so we can delete it later if successful
    ZID=`$NR -E --limit 1 $METRIC'[id]'`
    RFILEPFX=$TMPFILE.RFX
    mkdir $RFILEPFX
    RFX="RFXRFXRFX"

    G1=$TMPFILE.GO.1
    G2=$TMPFILE.GO.2

    for j in 0 1 2 3 4
    do
      for i in 0 1 2 3 4 5 6 7 8 9
      do
        $PYTHON -c "$TPGM" $RFILEPFX/$RFX$j$i $G1 $G2 > $TMPFILE.$j$i &
      done
    done

    # now wait for all of the programs to indicate they are ready
    while :
    do
        NREADY=`ls -l $RFILEPFX | grep $RFX | wc -l`
	if [ $NREADY -eq $NTIMES ]
	then
	    break
	fi
        sleep 2
    done

    # make the first go file to get them all busy waiting
    touch $G1

    # give them a chance to all start busy-waiting
    sleep 15

    # off to the races!
    touch $G2
    wait

    rm $G1 $G2
    rm -rf $RFILEPFX

    rm -f $TMPFILE
    touch $TMPFILE

    for j in 0 1 2 3 4
    do
      for i in 0 1 2 3 4 5 6 7 8 9
      do
        echo Results from: $j$i >> $TMPFILE
        cat $TMPFILE.$j$i >> $TMPFILE
        rm -f $TMPFILE.$j$i
        echo " - - - " >> $TMPFILE
      done
    done

    # There should be NTIMES - 1 "NoChange" entries and only one that changed it
    X=`grep NoChange $TMPFILE | wc -l`
    if [ $X -ne `$PYTHON -c "print($NTIMES - 1)"` ]
    then
      Y=`$PYTHON -c "print($NTIMES - $X)"`
      echo "The onlyIfChanged operation is not atomic. It changed $Y times."
      echo "Details of log file follow: - - - - - - - - - -"
      cat $TMPFILE
      echo "end of log file - - - - - - - - -"
      EXITSTATUS=1
    fi
}

if [ $QUICK = no ]
then
  infomsg "many parallel onlyIfChanged updates - atomicity test"
  yatom
else
  quickmsg "Skipping test of parallel onlyIf updates"
fi

# TEST like ...
doNR -wIq $METRIC '{ "kind": "like" }'

# see if the Like is actually there now
verifyNR "like" "[kind]" -I --limit 1 "$METRIC[kind]"


#
# Make some value events, then test to see if deleting them works
#
VSQ1=17
VSQ2=42
VSQ3=62
VSQ4=69
VSQ5=666


# this is a brain dead way to do it but copy/paste was better than
# engineering some shell array hack or relying on bash

infomsg "event deletion... first making events"
doNR -wq $METRIC $VSQ1
doNR -S --limit 1 "${METRIC}[id]"
VID1=$RESULT

doNR -wq $METRIC $VSQ2
doNR -S --limit 1 "${METRIC}[id]"
VID2=$RESULT

doNR -wq $METRIC $VSQ3
doNR -S --limit 1 "${METRIC}[id]"
VID3=$RESULT

doNR -wq $METRIC $VSQ4
doNR -S --limit 1 "${METRIC}[id]"
VID4=$RESULT

doNR -wq $METRIC $VSQ5
doNR -S --limit 1 "${METRIC}[id]"
VID5=$RESULT

verifyNR "$VSQ5" "5th value" $METRIC

doNR --delete -E -q $METRIC $VID4

verifyNR "$VSQ5" "5th value after deleting 4th" $METRIC

# now when we delete VID5 the value should become #3 bcs we deleted 4
doNR --delete -E -q $METRIC $VID5

verifyNR "$VSQ3" "3rd value after deleting 4th and 5th" $METRIC

# delete #4 again should get error
verifyNR "" "re-delete #4" "EXIT:1" --delete -E -q $METRIC $VID4

# testing --delete on interactions
# make a comment
infomsg "interaction deletion... first making interactions"
CMT="THIS IS THE COMMENT FOR WHICH WE ARE LOOKING"
doNR -wIq $METRIC "$CMT"

verifyNR "$CMT" "comment readback" -I --limit 1 "$METRIC[commentBody]"

doNR -I --limit 1 "${METRIC}[id]"
CMTID="$RESULT"

doNR --delete -Iq $METRIC $CMTID

# now the magic comment shouldn't be in there anywhere
infomsg "grepping stream output to ensure comment is gone..."
$NR -S $METRIC | grep -q "$CMT"
if [ $? = 0 ]
then
  failout "the designated comment is still visible in the stream"
fi
infomsg "It is gone! (yay!)"

# testing photos... first make a tiny GIF file (one pixel image)
GIFDATA="\\x47\\x49\\x46\\x38\\x39\\x61\\x01\\x00\\x01\\x00\\x80\\x00\\x00\\xff\\xff\\xff\\x00\\x00\\x00\\x2c\\x00\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x02\\x02\\x44\\x01\\x00\\x3b"

GIFFILE=/tmp/g$$.gif
GIFFILE2=/tmp/g2$$.gif

GIFPGM="s = \"${GIFDATA}\"
f = open(\"$GIFFILE\", \"wb\")
f.write(b\"$GIFDATA\")
f.close()
"

$PYTHON -c "$GIFPGM"

# set the photo
doNR -wPq $METRIC $GIFFILE

# get the URL of the photo
doNR -P $METRIC
PhotoURL="$RESULT"

infomsg "the photoURL is: $PhotoURL"

# at one point the Numerous server photo function was broken and that
# caused the URL being None here even though it should be something else.
# We check for that... may as well
if [ "x$PhotoURL" = "xNone" ]
then
  echo "Bad photo URL ... photo test skipped"
  EXITSTATUS=1
else
  # get the photo... we use python/requests because we know we have them
  # vs some platforms having curl and some wget etc. We don't need to test
  # for errors here because ultimately they will be caught by the cmp check

  READPGM="import requests
r = requests.get(\"`cat $TMPFILE`\")
f = open(\"$GIFFILE2\", \"wb\")
bytes = r.content
f.write(bytes)
f.close()
"

  $PYTHON -c "$READPGM"

  # above replaces this:
  #curl --silent `cat $TMPFILE` > $GIFFILE2

  # compare the photo with what we had set it to be
  cmp -l $GIFFILE $GIFFILE2
  if [ $? != 0 ]
  then
    echo "files do not compare"
    # may as well keep going but note this failure of course
    EXITSTATUS=1
  fi

  # test photo deletion
  doNR --delete -Pq $METRIC
fi

rm -f $GIFFILE $GIFFILE2

# photo URL should be None now
verifyNR "None" "Expected None for photo URL" -P $METRIC

# final output just print the stream
infomsg "Now just outputting the resulting stream"
doNR -S $METRIC

#
# create 200 comments just to make sure the chunked iterators work
#

if [ $QUICK = no ]
then
  infomsg "testing 200 x $NR -Iwq $METRIC commentNNN"

  CMTS=""
  for i in 0 1
  do
    for j in 0 1 2 3 4 5 6 7 8 9
    do
      CMTS="$CMTS cmt$i${j}0 cmt$i${j}1 cmt$i${j}2 cmt$i${j}3 cmt$i${j}4"
      CMTS="$CMTS cmt$i${j}5 cmt$i${j}6 cmt$i${j}7 cmt$i${j}8 cmt$i${j}9"
      doNR -wIq $METRIC cmt$i${j}0 $METRIC cmt$i${j}1 $METRIC cmt$i${j}2 $METRIC cmt$i${j}3 $METRIC cmt$i${j}4 $METRIC cmt$i${j}5 $METRIC cmt$i${j}6 $METRIC cmt$i${j}7 $METRIC cmt$i${j}8 $METRIC cmt$i${j}9 >/dev/null
      #
      # we shoot one of the comments on purpose to test the test code (!)
      #
      if [ $i = 0 ]
      then
        if [ $j = 3 ]
        then
          infomsg "deleting one of the 200 comments along the way"
          # shoot this comment
          doNR -I --limit 1 "${METRIC}[id]"
          SHOTID=$RESULT
          doNR --delete -I $METRIC $SHOTID
          SHOT="cmt039"     # XXX ugh, but easiest way
        fi
      fi
    done
  done

  infomsg "verifying all those comments were stored correctly"

  #
  # every comment made should be in the stream now...
  # ... except the one comment we shoot on purpose to test the test code!

  $NR -S $METRIC > $TMPFILE

  for m in $CMTS
  do
    grep -q $m $TMPFILE
    if [ $? != 0 ]
    then
      if [ x"$m" != x"$SHOT" ]
      then
        failout CONTINUE "did not find $m in output"
        EXITSTATUS=1
      fi
    else
      # but this one is SUPPOSED to be missing
      if [ x"$m" = x"$SHOT" ]
      then
        failout CONTINUE "still FOUND $m in output after deleting it"
        EXITSTATUS=1
      fi
    fi
  done

  echo "TESTING::: ALSO verifying via $NR -I $METRIC  (just interactions)"
  $NR -I $METRIC > $TMPFILE

  for m in $CMTS
  do
    grep -q $m $TMPFILE
    if [ $? != 0 ]
    then
      if [ x"$m" != x"$SHOT" ]
      then
        failout CONTINUE "did not find $m in output"
        EXITSTATUS=1
      fi
    else
      # but this one is SUPPOSED to be missing
      if [ x"$m" = x"$SHOT" ]
      then
        failout CONTINUE "still FOUND $m in output after deleting it"
        EXITSTATUS=1
      fi
    fi
  done
else
  quickmsg "Skipping the creation of a gazillion comments"
fi

#
# This next test makes sure the metrics collection iteration works right
# To test that we have to make a whole lotta variables. So here goes.
#
# This part takes a while so it is skipped if you ask for QUICK mode
#

if [ $QUICK = no ]
then
  infomsg "About to create many metrics; only some shown in output"

  for i in 0 1 2 3
  do
    for j in 0 1 2 3
    do
      for k in 0 1 2 3
      do
        M=DELETE-ME-XXX-DELETE-ME-$i$j$k
        Mparams='{ "private" : true }'
        if [ "$j$k" = "00" ]
        then
          infomsg "$NR -wM +$M $Mparams"
        fi
        $NR -wM +$M "$Mparams" > $TMPFILE
        if [ $? != 0 ]
        then
          failout "$NR -wM +$M $Mparams"
        else
          DELETE_THESE="$DELETE_THESE `cat $TMPFILE`"
        fi
      done
    done
  done
else
  quickmsg "Skipping the creation/deletion of a gazillion metrics"
fi

# at this point it's a royal pain to exit early, so track it this way
EXITSTATUS=0

#
# Get a list of metrics
#
infomsg "plain $NR to search for all metrics we made"
$NR > $TMPFILE
if [ $? != 0 ]; then echo "failed"; EXITSTATUS=1; fi

#
# every variable we made should be in that output
#
for m in $DELETE_THESE
do
  grep -q $m $TMPFILE
  if [ $? != 0 ]
  then
    failout CONTINUE "did not find $m in output"
    EXITSTATUS=1
  fi
done

#
# Now delete all the variables we created for this test
#
doNR -q --killmetric $DELETE_THESE

rm -f $TMPFILE
rm -f $GIFFILE
exit $EXITSTATUS
