#!/bin/sh
#
# test script for the nr program
#
#


PATH=$HOME/bin:$PATH
NR=nr
PYTHON=python3
TMPFILE=/tmp/$$
DELETE_THESE=""
EXITSTATUS=0
DQ='"'           # handy at times

QUICK=no
DEVTEST=no
NRTEST=./nrTEST      # only used in DEVTEST case
T429TEST=./t429.py   # only used in the DEVTEST case

#
# OPTIONS
#    -Q skips some of the slower tests ("quick")
#    -X allows override of nr and python via environment variables (debug/test).
#    -D is for development testing and recursively invokes itself to test
#       python and python3 using the local development tree (yeehah!)
#
#
#    -C allows for continuing after certain particular failures.
#       (workaround for testing despite certain server bugs, e.g., atomicity)
#
#    -4 do not run the 429 throttling test. This is also implied by -Q
#
#    --500 specifically ignore (retry) 500/504 errors from the server.
#          XXX this is a temporary hack when NumerousApp server is being buggy
#
#

SOMECONTINUE=no
RUN429=yes

# allows for combining e.g., -QX and also supports the --option form (for --500)

while [ $# -gt 0 ]
do
  case "x$1" in
    # all the long forms go here like this
    x--500)
      NR500="--retry500"
      shift
      ;;

    x--*)
      echo "Illegal option $1"
      exit 2
      ;;


    # all the single opts have to be further getopt-ified and looped here
    x-*)
      args=`getopt XQCD4 "$1"`
      if [ $? -ne 0 ]
      then
        echo "Usage: -XQDC4 --500"
        exit 2
      fi
      for arg in $args
      do
        case "x$arg" in
          x-4)
            RUN429=no
            ;;

          x-C)
            SOMECONTINUE="yes"
            ;;

          x-Q)
            QUICK=yes
            RUN429=no
            ;;

          x-X)
            if [ "x$PYX" != "x" ]; then PYTHON="$PYX"; fi
            if [ "x$NRX" != "x" ]; then NR="$NRX"; fi
            echo "Using \"$PYTHON\" for python interpreter"
            echo "Using \"$NR\" for the nr command program"
            if [ "x$NRTX" != "x" -a "x$NRTX" != "x$NRTEST" ]
            then
                echo " ... and NRTEST is overridden to $NRTX"
                NRTEST="$NRTX"
            fi
            ;;

          x-D)
            DEVTEST=yes
            ;;
        esac
      done
      shift
      ;;

    *)
      echo "No additional arguments required/allowed"
      exit 2
      ;;
  esac
done

if [ "$DEVTEST" = "yes" ]
then
    echo DEVELOPMENT TESTING MODE

    if [ ! -x $NRTEST ]; then echo "no $NRTEST - aborting"; exit 1; fi
    QK=""
    if [ "$QUICK" = "yes" ]; then QK="-Q"; fi

    CT=""
    if [ "$SOMECONTINUE" = "yes" ]; then CT="-C"; fi

    NRPY=../shell-cmd/nr.py

    echo ' - - - - TESTING PYTHON 2 - - - -'

    NR500="$NR500" PYX=python NRX="python $NRPY" NRTX="$NRTEST" PYTHONPATH=.. $NRTEST -X $QK $CT
    if [ $? -ne 0 ]; then echo "python v2 failed"; exit 1; fi

    if [ $RUN429 = "yes" ]
    then
        echo ' ... ... T429 PYTHON 2 ... ...'
        echo 'This test forces HTTP code 429 throttling. Takes a minute or so.'
        echo 'Just expect a bunch of raw statistics output if this works'
        echo ' ... '
        PYTHONPATH=.. python $T429TEST --statistics
        echo ' ... ... T429 DONE(P2) ... ...'
    fi

    echo ' - - - - TESTING PYTHON 3 - - - -'

    NR500="$NR500" PYX=python3 NRX="python3 $NRPY" NRTX="$NRTEST" PYTHONPATH=.. $NRTEST -X $QK $CT
    if [ $? -ne 0 ]; then echo "python3 failed"; exit 1; fi

    if [ $RUN429 = "yes" ]
    then
        echo ' ... ... T429 PYTHON 3 ... ...'
        echo 'This test forces HTTP code 429 throttling. Takes a minute or so.'
        echo 'Just expect a bunch of raw statistics output if this works'
        echo ' ... '
        PYTHONPATH=.. python3 $T429TEST --statistics
        echo ' ... ... T429 DONE(P3) ... ...'
    fi

    exit 0
fi


####### yatom test program #######
# This is the python program that runs the atomicity tests
# We just recreate it each time in a tmp file because it's easy with a HERE DOC
#
ATOMICTESTPROGRAM=/tmp/nrAtomicTester$$
cat > $ATOMICTESTPROGRAM <<EOF

import argparse
import numerous
import threading

try:
  import queue
except:    # python 2
  import Queue as queue


parser = argparse.ArgumentParser()
parser.add_argument('-n', '--nwrites', type=int, default=50)
parser.add_argument('-m', '--metric')
parser.add_argument('-p', '--parallel', type=int, default=-1)
parser.add_argument('testtype', choices=['ADD', 'ONLY'])
args = parser.parse_args()

if args.parallel < 1:
    args.parallel = args.nwrites

def tester(k, mID, n, wargs, q):
    nr = numerous.Numerous(apiKey=k, throttle= lambda nr, tp, td, up:
                (tp['result-code'] == 429) and up[0](nr, tp, up[1], up[2]))
    testmetric = nr.metric(mID)
    for i in range(n):
        try:
            v = testmetric.write(1, **wargs)
        except numerous.NumerousMetricConflictError:
            v = "NoChange"
        q.put(v)

apiKey = numerous.numerousKey(None)
nrMain = numerous.Numerous(apiKey=apiKey)

testmetric = nrMain.metric(args.metric)

testmetric.write(0)

if args.testtype == "ADD":
    wargs = { 'add' : True }
else:
    wargs = { 'onlyIf' : True }

outputQ = queue.Queue()

# create the threads...
theThreads = []
for i in range(args.parallel):
    nToWrite = args.nwrites//args.parallel
    # account for residue, some threads will write 1 extra
    if i < (args.nwrites%args.parallel):
        nToWrite += 1

    threadArgs = (apiKey, testmetric.id, nToWrite, wargs, outputQ)
    theThreads.append(threading.Thread(target=tester, args=threadArgs))

# start all the threads...
for t in theThreads:
    t.start()

# wait for all the threads
for t in theThreads:
    t.join()

# print all the results
while True:
    try:
        print(outputQ.get(block=False))
    except queue.Empty:
        break

exit(0)

EOF


# silly little function to add numbers using python
# because sometimes (believe it or not) bc isn't there
# We KNOW python is here
#
# result in RESULT
add() {
  RESULT=`$PYTHON -c "print( $1 + $2 )"`
}

# report how much API quota is available, for infotainment purposes.
# Note that we turn off the Numerous class API throttling so we can 
# query the server (make one API call) and get a result without ourselves
# being subject to rate throttling...

getAPIQuota() {
  TPGM="
import numerous
remain = -1
refresh = -1
nr = numerous.Numerous(apiKey=\"$APIKEY\", throttle=lambda nr,tp,td,up: False)
try:
    nr.ping()
    remain=nr.statistics['rate-remaining']
    refresh=nr.statistics['rate-reset']
except numerous.NumerousError as x:
    if x.code in (429,500,504): # we are in overloaded condition already
        remain = 0              # report that as zero
        refresh=nr.statistics['rate-reset']
    else:
        raise                   # anything else, not sure what is going on, reraise it

print('{} {}'.format(remain, refresh))
"
  $PYTHON -c "$TPGM"
}




# clever hack to ensure we have at least $1 + $2 API quota remaining
# (or sleep until we get fresh allocation). This is used before
# the atomicity tests to ensure they won't be foiled (slowed down)
# by rate throttling when their entire point is to hammer the server
ensureAPIQuota() {
  if [ "x$2" = "x" ]
  then
    EXTRA=0
  else
    EXTRA=$2
  fi

  NEEDED=`$PYTHON -c "print( $1 + $EXTRA )"`
  infomsg "Ensuring at least $NEEDED API quota available..."
  getAPIQuota >$TMPFILE
  HAVE=`awk '{print $1}' $TMPFILE`
  REFRESH=`awk '{print $2}' $TMPFILE`

  if [ $HAVE -lt $NEEDED ]
  then
    if [ $REFRESH -lt 1 ]; then REFRESH=66; fi
    infomsg " ... Delaying $REFRESH seconds for new API quota, only have $HAVE."
    sleep $REFRESH
  else
    infomsg " ... Have $HAVE API quota; no delay required."
  fi
}


# for bailing out with a message
failout() {
    DIE=yes
    if [ "x$1" = "xCONTINUE" ]; then DIE=no; shift; fi
    echo "FAILED:::: $*"
    if [ "$DIE" = "yes" ]; then exit 1; fi
}


#
# idiomatic way to do something with $NR, log it, check for status, etc.
# If $1 looks like "EXIT:N" then the expected result is $? = N
#
# Will exit 1 if fails, otherwise RESULT is set to the result.
#
doNR() {
  GOODSTATUS=0
  case "x$1" in
    xEXIT:*)
      GOODSTATUS=`echo $1 | sed -e 's/^.*://'`
      shift
      ;;
  esac

  if [ "x$NR500" = "x" ]     # XXX just to make the output pretty (no extra space) ...
  then
    echo "TESTING::: $NR $*"
  else
    echo "TESTING::: $NR $NR500 $*"
  fi

  $NR $NR500 "$@" > $TMPFILE
  STATUS=$?
  if [ $STATUS != $GOODSTATUS ]; then failout "... $NR exit status $STATUS"; fi
  RESULT=`cat $TMPFILE`
}

#
# idiomatic way to doNR and test result for a specific result
# Expected result is $1 ; Detail info for unexpected is $2;
# Remaining arguments go to doNR
#
verifyNR() {
  DIE=yes
  case "x$1" in
    xCONTINUE)
      DIE=no
      shift
      ;;

    xSOMECONTINUE)
      if [ $SOMECONTINUE = "yes" ]
      then
        DIE="no"
      fi
      shift
      ;;
  esac

  EXPECTED=$1
  ERRMSG=$2
  shift 2

  doNR "$@"
  if [ "x$RESULT" != "x$EXPECTED" ]
  then
    if [ $DIE = "no" ]
    then
      failout CONTINUE "${ERRMSG}: Expected \"$EXPECTED\" Got \"$RESULT\""
    else
      failout "${ERRMSG}: Expected \"$EXPECTED\" Got \"$RESULT\""
    fi
  fi
}

verifyPython() {
  infomsg "$1"
  $PYTHON -c "$3" > $TMPFILE
  if [ $? -ne 0 ]; then failout "non-zero exit from python"; fi
  RESULT=`cat $TMPFILE`
  if [ "x$RESULT" != "x$2" ]; then failout "expected: $2, got $RESULT"; fi
}

#
# Just a way to put an info into the output stream, properly formatted
#
infomsg() {
  echo "::INFO:::: $*"
}

# variant for things skipped via -Q
quickmsg() {
  echo ":::QUICK:: $*"
}

# utility function to parse a JSON object and return (via RESULT) a field
# JSON object in $1
# desired field key in $2
parsejson() {
  JPGM="import json; d = json.loads('"$1"'); print(d['"$2"'])"
  RESULT=`$PYTHON -c "$JPGM"`
}

#
# utility function to...
#   Take the JSON object in $1 which should be NR output
#   Go into the Results top level field
#   take the $2'th element of the Results array
#   take the result element of that
#   return the $3 element of that
#
# typical use if you expected one JSON result from NR would be
#
#    parseNRJSON "$J" 0 description
#
# where J is the NR output and, for example, description is the field you want
#
parseNRJSON() {
  JPGM="import json
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('j')
args = parser.parse_args()

d = json.loads(args.j)
print(d['Results']["$2"]['result']['"$3"'])
"

  RESULT=`$PYTHON -c "$JPGM" "$1"`
}




#
# Test the -k function first of all
#

if [ "x$NUMEROUSAPIKEY" = x ]
then
  NUMEROUSAPIKEY=$HOME/.myCred export NUMEROUSAPIKEY
fi

infomsg "Version under test:" `$NR -V`

# just to get a more human-friendly error message handle the -k manually
$NR -k > $TMPFILE
if [ $? -ne 0 ]; then failout "Unable to get apikey. Check NUMEROUSAPIKEY."; fi
APIKEY=`cat $TMPFILE`

#
# See if we can successfully connect
#
infomsg "Contacting server to verify apikey is valid."
doNR -q

#
# Create a test metric to bang on
#
M=nrTEST$$
MVAL=999
Mparams="{ \"private\" : true, \"value\" : $MVAL }"


doNR -wM +$M "$Mparams"
METRIC=$RESULT

infomsg "created $METRIC"

DELETE_THESE="$DELETE_THESE $METRIC"

# see if it got created with the correct privacy and value
verifyNR $MVAL "Wrong initial value" $METRIC
verifyNR True "Wrong private setting" $METRIC[private]

# see if we can read it with the other allowed metric ID forms
doNR $METRIC'[self]'
verifyNR $MVAL "Reading via $RESULT" $RESULT

doNR $METRIC'[web]'
verifyNR $MVAL "Reading via $RESULT" $RESULT

# testing a variety of other ID forms we need to use python to get at them
infomsg "Testing a variety of ID forms in nr.metric() constructor"
for ID in \
  "$METRIC" \
  "{ 'metricId' : $METRIC }" \
  "{ 'metricId' : $DQ$METRIC$DQ }" \
  "{ 'id' : $METRIC }" \
  "{ 'id' : $DQ$METRIC$DQ }"
do

  TPGM="import numerous
nr = numerous.Numerous(apiKey=\"$APIKEY\")
i = $ID
print(nr.metric(i).read())
"

  verifyPython " .. id: $ID" $MVAL "$TPGM"
done

# testing the exception cases
  TPGM="import numerous
nr = numerous.Numerous(apiKey=\"$APIKEY\")
i = {}
try:
  print(nr.metric(i).read())
  exit(1)
except KeyError:
  print('KeyError')
  exit(0)
"
verifyPython " .. id: {}" "KeyError" "$TPGM"

  TPGM="import numerous
nr = numerous.Numerous(apiKey=\"$APIKEY\")
i = {'id' : 'something bogus'}
try:
  print(nr.metric(i).read())
  exit(1)
except numerous.NumerousError as x:
  print('NumerousError {}'.format(x.code))
  exit(0)
"
verifyPython " .. id: {'id' : 'something bogus'}" "NumerousError 400" "$TPGM"

# write a value
verifyNR $$ "wrong write result" -w $METRIC $$

# write same value with -y and expect exit 1
verifyNR "" "-wy" "EXIT:1" -wyq $METRIC $$

# interject a comment
C='this be the naked comment'
doNR -wIq $METRIC "$C"
verifyNR "$C" "Comment readback" -I --limit 1 "$METRIC[commentBody]"

# AGAIN write the same value with -y, should "fail"
infomsg "-wyq test AGAIN"
verifyNR "" "-wy" "EXIT:1" -wyq $METRIC $$

# increment by 1
doNR $METRIC
add $RESULT 1
NEWVAL=$RESULT
verifyNR $NEWVAL "Added 1" -w+ $METRIC 1

# now writing the original test value with -y should succeed
verifyNR $$ "Rewriting $$" -wy $METRIC $$

# see if the add really works correctly...
verifyNR 17 "Writing 17" -w $METRIC 17
verifyNR 20 "Adding 3" -w+ $METRIC 3
verifyNR -1 "Subtracting 21" -w+ $METRIC -21
verifyNR -1 "Read back" $METRIC

# test on a totally separate metric to test out the 'updated' write() feature

infomsg "Testing the \"updated\" timestamp feature of write()"
infomsg "(uses a python program not the NR command)"

TPGM="import numerous

nr = numerous.Numerous(apiKey=\"$APIKEY\")
metric = nr.createMetric(\"nrTXX$$\", attrs={ 'private' : True })

testval = 99
r = metric.write(testval, dictionary=True)
ids = { testval : r['id'] }

# write some values from the past
testvector = [ 55, 44, 88, 66, 33 ]
testvectormax = 88 # XXX we just know this

for i in testvector:
  tstr = '2001-01-01T10:00:01.0{}Z'.format(i)
  r = metric.write(i, updated=tstr, dictionary=True)
  ids[i] = r['id']

# since all those were from earlier than the testval, value should be testval
if metric.read() != testval:
  exit(1)

# delete the testval we wrote, leaving the timestamped values only
metric.eventDelete(ids[testval])

# it should be whatever is the max in the test vector now
if metric.read() != testvectormax:
  exit(1)

metric.crushKillDestroy()
exit(0)
"

$PYTHON -c "$TPGM"
if [ $? -ne 0 ]
then
  failout "updated timestamp write test failed"
fi
infomsg "Succeeded"

# try making an error entry
ErrString="This is the error info"
ErrInfo="{ \"kind\": \"error\", \"commentBody\": \"$ErrString\" }"

verifyNR "" "Setting an error" -wIq $METRIC "$ErrInfo"

# see if that error is actually there now
verifyNR "error" "Reading back the [kind]" -I --limit 1 "$METRIC[kind]"

# and check the text
verifyNR "$ErrString" "Readback errstring" -I --limit 1 "$METRIC[commentBody]"

# test updating a metric's description
Desc="This is the metric's porpoise in life"
Units="blivets"
updateJSON="{ \"description\": \"$Desc\", \"units\" : \"$Units\" }"

doNR -wMq $METRIC "$updateJSON"
verifyNR "$Desc" "[description]" "${METRIC}[description]"
verifyNR "$Units" "[units]" "${METRIC}[units]"

# once more to check read/mod/write feature
Desc="something else"
updateJSON="{ \"description\": \"$Desc\" }"
doNR -wMq $METRIC "$updateJSON"
verifyNR "$Desc" "[description(2)]" "${METRIC}[description]"
verifyNR "$Units" "[units(2)]" "${METRIC}[units]"

# some JSON option testing (testing the nr command itself)
V=123
doNR -wq $METRIC $V
doNR -j $METRIC $METRIC $METRIC
J="$RESULT"
for i in 0 1 2
do
  parseNRJSON "$J" $i value
  if [ "x$RESULT" != "x$V" ]
  then
    failout "Got $RESULT expected $V for element $i"
  fi
done

Desc="{ a bunch of stuff in unbalanced] braces {}"
updateJSON="{ \"description\": \"$Desc\" }"

doNR -wMq $METRIC "$updateJSON"
doNR -j $METRIC
J="$RESULT"
parseNRJSON "$J" 0 description
if [ "x$RESULT" != "x$Desc" ]
then
  failout "Got $RESULT expected $Desc"
fi

# make a "timer" metric to bang on
TMR=nrTMRTEST$$
TMRparams='{ "private" : true, "kind" : "timer" }'

doNR -wM +$TMR "$TMRparams"
TMETRIC=$RESULT

infomsg "created metric $TMETRIC"

DELETE_THESE="$DELETE_THESE $TMETRIC"

# set it to a particular date
doNR -wq $TMETRIC "EPOCHTIME: 1/15/2011"   # nephew's birthday :)

# I don't really have a good way to test that the date got set correctly.
# Well, I could, but I'm too lazy to write all that shell code. So we're
# just happy here if the date conversion above didn't blow up. Declare victory.

# make another "virgin" metric to bang on
VGM=nrVGTEST$$
VGMparams='{ "private" : true }'

doNR -wM +$VGM "$VGMparams"
VGMETRIC=$RESULT

infomsg "created metric $VGMETRIC"

DELETE_THESE="$DELETE_THESE $VGMETRIC"

# make sure getting an empty collection of various flavors works
for ARG in E I S
do
  verifyNR "" "-${ARG}" -${ARG} $VGMETRIC
done


# fire off 100 add +1 operations in parallel.
# They are supposed to operate atomically (they didn't in the past
# but that was a server bug and is now fixed)

if [ $QUICK = yes ]
then
  quickmsg "Skipping atomicity test."
else
  NADD=100
  ensureAPIQuota $NADD 25
  infomsg "Atomicity test. $NADD ADD +1 in parallel"
  $PYTHON $ATOMICTESTPROGRAM -n $NADD -m $METRIC -p 10 ADD > $TMPFILE
  verifyNR SOMECONTINUE $NADD "Atomicity failed" $METRIC
fi

# fire off a bunch of "onlyIfChanged" operations in parallel
# only one of them should change the variable, the rest should be "NoChange"
#
# XXX the server does implement these atomically, so I've never been
#     able to verify whether this would expose any atomicity error.

# another version of the numerous server atomicity test
yatom() {

    NTIMES=100
    ensureAPIQuota $NTIMES 25
    $PYTHON $ATOMICTESTPROGRAM -n $NTIMES -p 10 -m "$METRIC" ONLY > $TMPFILE

    # There should be NTIMES - 1 "NoChange" entries and only one that changed it
    X=`grep NoChange $TMPFILE | wc -l`
    if [ $X -ne `$PYTHON -c "print($NTIMES - 1)"` ]
    then
      Y=`$PYTHON -c "print($NTIMES - $X)"`
      echo "The onlyIfChanged operation is not atomic. It changed $Y times."
      echo "Details of log file follow: - - - - - - - - - -"
      cat $TMPFILE
      echo "end of log file - - - - - - - - -"
      EXITSTATUS=1
    fi
}

if [ $QUICK = no ]
then
  infomsg "many parallel onlyIfChanged updates - atomicity test"
  yatom
else
  quickmsg "Skipping test of parallel onlyIf updates"
fi

rm -f $ATOMICTESTPROGRAM

# TEST like ...
doNR -wIq $METRIC '{ "kind": "like" }'

# see if the Like is actually there now
verifyNR "like" "[kind]" -I --limit 1 "$METRIC[kind]"


#
# Make some value events, then test to see if deleting them works
#
VSQ1=17
VSQ2=42
VSQ3=62
VSQ4=69
VSQ5=666


# this is a brain dead way to do it but copy/paste was better than
# engineering some shell array hack or relying on bash

infomsg "event deletion... first making events"
doNR -wq $METRIC $VSQ1
doNR -S --limit 1 "${METRIC}[id]"
VID1=$RESULT

doNR -wq $METRIC $VSQ2
doNR -S --limit 1 "${METRIC}[id]"
VID2=$RESULT

doNR -wq $METRIC $VSQ3
doNR -S --limit 1 "${METRIC}[id]"
VID3=$RESULT

doNR -wq $METRIC $VSQ4
doNR -S --limit 1 "${METRIC}[id]"
VID4=$RESULT

doNR -wq $METRIC $VSQ5
doNR -S --limit 1 "${METRIC}[id]"
VID5=$RESULT

verifyNR "$VSQ5" "5th value" $METRIC

doNR --delete -E -q $METRIC $VID4

verifyNR "$VSQ5" "5th value after deleting 4th" $METRIC

# now when we delete VID5 the value should become #3 bcs we deleted 4
doNR --delete -E -q $METRIC $VID5

verifyNR "$VSQ3" "3rd value after deleting 4th and 5th" $METRIC

# delete #4 again should get error
verifyNR "" "re-delete #4" "EXIT:1" --delete -E -q $METRIC $VID4

# testing --delete on interactions
# make a comment
infomsg "interaction deletion... first making interactions"
CMT="THIS IS THE COMMENT FOR WHICH WE ARE LOOKING"
doNR -wIq $METRIC "$CMT"

verifyNR "$CMT" "comment readback" -I --limit 1 "$METRIC[commentBody]"

doNR -I --limit 1 "${METRIC}[id]"
CMTID="$RESULT"

doNR --delete -Iq $METRIC $CMTID

# now the magic comment shouldn't be in there anywhere
infomsg "grepping stream output to ensure comment is gone..."
$NR -S $METRIC | grep -q "$CMT"
if [ $? = 0 ]
then
  failout "the designated comment is still visible in the stream"
fi
infomsg "It is gone! (yay!)"

# testing photos... first make a tiny GIF file (one pixel image)
GIFDATA="\\x47\\x49\\x46\\x38\\x39\\x61\\x01\\x00\\x01\\x00\\x80\\x00\\x00\\xff\\xff\\xff\\x00\\x00\\x00\\x2c\\x00\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x02\\x02\\x44\\x01\\x00\\x3b"

GIFFILE=/tmp/g$$.gif
GIFFILE2=/tmp/g2$$.gif

GIFPGM="s = \"${GIFDATA}\"
f = open(\"$GIFFILE\", \"wb\")
f.write(b\"$GIFDATA\")
f.close()
"

$PYTHON -c "$GIFPGM"

# set the photo
doNR -wPq $METRIC $GIFFILE

# get the URL of the photo
doNR -P $METRIC
PhotoURL="$RESULT"

infomsg "the photoURL is: $PhotoURL"

# at one point the Numerous server photo function was broken and that
# caused the URL being None here even though it should be something else.
# We check for that... may as well
if [ "x$PhotoURL" = "xNone" ]
then
  failout CONTINUE "Bad photo URL ... photo test skipped"
  EXITSTATUS=1
else
  # get the photo... we use python/requests because we know we have them
  # vs some platforms having curl and some wget etc. We don't need to test
  # for errors here because ultimately they will be caught by the cmp check

  READPGM="import requests
r = requests.get(\"`cat $TMPFILE`\")
f = open(\"$GIFFILE2\", \"wb\")
bytes = r.content
f.write(bytes)
f.close()
"

  $PYTHON -c "$READPGM"

  # above replaces this:
  #curl --silent `cat $TMPFILE` > $GIFFILE2

  # compare the photo with what we had set it to be
  cmp -l $GIFFILE $GIFFILE2
  if [ $? != 0 ]
  then
    echo "files do not compare"
    # may as well keep going but note this failure of course
    EXITSTATUS=1
  fi

  # test photo deletion
  doNR --delete -Pq $METRIC
fi

rm -f $GIFFILE $GIFFILE2

# photo URL should be None now
verifyNR "None" "Expected None for photo URL" -P $METRIC

# final output just print the stream
infomsg "Now just outputting the resulting stream"
doNR -S $METRIC

#
# create 200 comments just to make sure the chunked iterators work
#

if [ $QUICK = no ]
then
  # we don't really need to have any specific quota available; however, to be
  # nice to the server we delay here if we aren't already at least at 200
  ensureAPIQuota 200
  infomsg "testing 200 x $NR -Iwq $METRIC commentNNN"

  CMTS=""
  for i in 0 1
  do
    for j in 0 1 2 3 4 5 6 7 8 9
    do
      CMTS="$CMTS cmt$i${j}0 cmt$i${j}1 cmt$i${j}2 cmt$i${j}3 cmt$i${j}4"
      CMTS="$CMTS cmt$i${j}5 cmt$i${j}6 cmt$i${j}7 cmt$i${j}8 cmt$i${j}9"
      doNR -wIq $METRIC cmt$i${j}0 $METRIC cmt$i${j}1 $METRIC cmt$i${j}2 $METRIC cmt$i${j}3 $METRIC cmt$i${j}4 $METRIC cmt$i${j}5 $METRIC cmt$i${j}6 $METRIC cmt$i${j}7 $METRIC cmt$i${j}8 $METRIC cmt$i${j}9 >/dev/null
      #
      # we shoot one of the comments on purpose to test the test code (!)
      #
      if [ $i = 0 ]
      then
        if [ $j = 3 ]
        then
          infomsg "deleting one of the 200 comments along the way"
          # shoot this comment
          doNR -I --limit 1 "${METRIC}[id]"
          SHOTID=$RESULT
          doNR --delete -I $METRIC $SHOTID
          SHOT="cmt039"     # XXX ugh, but easiest way
        fi
      fi
    done
  done

  infomsg "verifying all those comments were stored correctly"

  #
  # every comment made should be in the stream now...
  # ... except the one comment we shoot on purpose to test the test code!

  $NR -S $METRIC > $TMPFILE

  for m in $CMTS
  do
    grep -q $m $TMPFILE
    if [ $? != 0 ]
    then
      if [ x"$m" != x"$SHOT" ]
      then
        failout CONTINUE "did not find $m in output"
        EXITSTATUS=1
      fi
    else
      # but this one is SUPPOSED to be missing
      if [ x"$m" = x"$SHOT" ]
      then
        failout CONTINUE "still FOUND $m in output after deleting it"
        EXITSTATUS=1
      fi
    fi
  done

  infomsg "ALSO verifying via $NR -I $METRIC  (just interactions)"
  $NR -I $METRIC > $TMPFILE

  for m in $CMTS
  do
    grep -q $m $TMPFILE
    if [ $? != 0 ]
    then
      if [ x"$m" != x"$SHOT" ]
      then
        failout CONTINUE "did not find $m in output"
        EXITSTATUS=1
      fi
    else
      # but this one is SUPPOSED to be missing
      if [ x"$m" = x"$SHOT" ]
      then
        failout CONTINUE "still FOUND $m in output after deleting it"
        EXITSTATUS=1
      fi
    fi
  done
else
  quickmsg "Skipping the creation of a gazillion comments"
fi

#
# This next test makes sure the metrics collection iteration works right
# To test that we have to make a whole lotta variables. So here goes.
#
# This part takes a while so it is skipped if you ask for QUICK mode
#

if [ $QUICK = no ]
then
  infomsg "About to create many metrics; only some shown in output"

  for i in 0 1 2 3
  do
    for j in 0 1 2 3
    do
      for k in 0 1 2 3
      do
        M=DELETE-ME-XXX-DELETE-ME-$i$j$k
        Mparams='{ "private" : true }'
        if [ "$j$k" = "00" ]
        then
          infomsg "$NR -wM +$M $Mparams"
        fi
        $NR -wM +$M "$Mparams" > $TMPFILE
        if [ $? != 0 ]
        then
          failout "$NR -wM +$M $Mparams"
        else
          DELETE_THESE="$DELETE_THESE `cat $TMPFILE`"
        fi
      done
    done
  done
else
  quickmsg "Skipping the creation/deletion of a gazillion metrics"
fi

# at this point it's a royal pain to exit early, so track it this way
EXITSTATUS=0

#
# Get a list of metrics
#
infomsg "plain $NR to search for all metrics we made"
doNR
echo "$RESULT" > $TMPFILE

#
# every variable we made should be in that output
#
for m in $DELETE_THESE
do
  grep -q $m $TMPFILE
  if [ $? != 0 ]
  then
    failout CONTINUE "did not find $m in output"
    EXITSTATUS=1
  fi
done

#
# Now delete all the variables we created for this test
#
doNR -q --killmetric $DELETE_THESE

rm -f $TMPFILE
rm -f $GIFFILE
exit $EXITSTATUS
