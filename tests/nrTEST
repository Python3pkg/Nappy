#!/bin/sh
#
# test script for the nr program
#
# You should set NUMEROUSAPIKEY in the environment as appropriate.
# If you don't set it, we'll try ~/.myCred which probably isn't right.
#
# For the fine-grained permissions test you will need a second user ID
# and apikey, which you should supply via NUMEROUSAPIKEY2 environment
# variable. There is no default for that; if you do not supply the
# secondary api key then some of the fine-grained permissions tests
# will be skipped (some can be run with just one ID, but anything that
# actually tries to test enforcement of permissions will be skipped)
#



PATH=$HOME/bin:$PATH
NR=nr
PYTHON=python3
TMPFILE=/tmp/$$
DELETE_THESE=""
EXITSTATUS=0
DQ='"'           # handy at times

QUICK=no
DEVTEST=no
NRTEST=./nrTEST      # only used in DEVTEST case
T429TEST=./t429.py   # only used in the DEVTEST case

TEST_PREFIX="  :test:  "
FAIL_PREFIX="***FAIL***"
INFO_PREFIX="..INFO..  "
QUIK_PREFIX=" :quick:  "

#
# OPTIONS
#    -Q skips some of the slower tests ("quick")
#    -X allows override of nr and python via environment variables (debug/test).
#    -D is for development testing and recursively invokes itself to test
#       python and python3 using the local development tree (yeehah!)
#
#
#    -C allows for continuing after certain particular failures.
#       (workaround for testing despite certain server bugs, e.g., atomicity)
#
#    -4 do not run the 429 throttling test. This is also implied by -Q
#
#    -3 do not run python 3 (only applies with -D)
#    -2 do not run python 2 (only applies with -D)
#
#    --500 specifically ignore (retry) 500/504 errors from the server.
#          XXX this is a temporary hack when NumerousApp server is being buggy
#
#

SOMECONTINUE=no
RUN429=yes
DPY3=yes
DPY2=yes

# allows for combining e.g., -QX and also supports the --option form (for --500)

while [ $# -gt 0 ]
do
  case "x$1" in
    # all the long forms go here like this
    x--500)
      NR500="--retry500"
      shift
      ;;

    x--*)
      echo "Illegal option $1"
      exit 2
      ;;


    # all the single opts have to be further getopt-ified and looped here
    x-*)
      args=`getopt XQCD432 "$1"`
      if [ $? -ne 0 ]
      then
        echo "Usage: -XQDC4 --500"
        exit 2
      fi
      for arg in $args
      do
        case "x$arg" in
          x-4)
            RUN429=no
            ;;

          x-3)
            DPY3=no
            ;;

          x-2)
            DPY2=no
            ;;

          x-C)
            SOMECONTINUE="yes"
            ;;

          x-Q)
            QUICK=yes
            RUN429=no
            ;;

          x-X)
            if [ "x$PYX" != "x" ]; then PYTHON="$PYX"; fi
            if [ "x$NRX" != "x" ]; then NR="$NRX"; fi
            echo "Using \"$PYTHON\" for python interpreter"
            echo "Using \"$NR\" for the nr command program"
            if [ "x$NRTX" != "x" -a "x$NRTX" != "x$NRTEST" ]
            then
                echo " ... and NRTEST is overridden to $NRTX"
                NRTEST="$NRTX"
            fi
            ;;

          x-D)
            DEVTEST=yes
            ;;
        esac
      done
      shift
      ;;

    *)
      echo "No additional arguments required/allowed"
      exit 2
      ;;
  esac
done

if [ "$DEVTEST" = "yes" ]
then
    echo DEVELOPMENT TESTING MODE

    if [ ! -x $NRTEST ]; then echo "no $NRTEST - aborting"; exit 1; fi
    QK=""
    if [ "$QUICK" = "yes" ]; then QK="-Q"; fi

    CT=""
    if [ "$SOMECONTINUE" = "yes" ]; then CT="-C"; fi

    NRPY=../shell-cmd/nr.py

    if [ $DPY2 = yes ]
    then
      echo ' - - - - TESTING PYTHON 2 - - - -'

      NR500="$NR500" PYX=python NRX="python $NRPY" NRTX="$NRTEST" PYTHONPATH=.. $NRTEST -X $QK $CT
      if [ $? -ne 0 ]; then echo "python v2 failed"; exit 1; fi

      if [ $RUN429 = "yes" ]
      then
          echo ' ... ... T429 PYTHON 2 ... ...'
          echo 'This test forces HTTP code 429 throttling. Takes a minute or so.'
          echo 'Just expect a bunch of raw statistics output if this works'
          echo ' ... '
          # XXX PYTHONWARNINGS cruft because of SSL warnings (ick)
          PYTHONWARNINGS=ignore PYTHONPATH=.. python $T429TEST --statistics
          echo ' ... ... T429 DONE(P2) ... ...'
      fi
    fi


    if [ $DPY3 = yes ]
    then
      echo ' - - - - TESTING PYTHON 3 - - - -'
      NR500="$NR500" PYX=python3 NRX="python3 $NRPY" NRTX="$NRTEST" PYTHONPATH=.. $NRTEST -X $QK $CT
      if [ $? -ne 0 ]; then echo "python3 failed"; exit 1; fi

      if [ $RUN429 = "yes" ]
      then
          echo ' ... ... T429 PYTHON 3 ... ...'
          echo 'This test forces HTTP code 429 throttling. Takes a minute or so.'
          echo 'Just expect a bunch of raw statistics output if this works'
          echo ' ... '
          PYTHONPATH=.. python3 $T429TEST --statistics
          echo ' ... ... T429 DONE(P3) ... ...'
      fi
    fi

    exit 0
fi


####### yatom test program #######
# This is the python program that runs the atomicity tests
# We just recreate it each time in a tmp file because it's easy with a HERE DOC
#
ATOMICTESTPROGRAM=/tmp/nrAtomicTester$$
cat > $ATOMICTESTPROGRAM <<EOF

import argparse
import numerous
import threading

try:
  import queue
except:    # python 2
  import Queue as queue


parser = argparse.ArgumentParser()
parser.add_argument('-n', '--nwrites', type=int, default=50)
parser.add_argument('-m', '--metric')
parser.add_argument('-p', '--parallel', type=int, default=-1)
parser.add_argument('testtype', choices=['ADD', 'ONLY'])
args = parser.parse_args()

if args.parallel < 1:
    args.parallel = args.nwrites

def tester(k, mID, n, wargs, q):
    nr = numerous.Numerous(apiKey=k, throttle= lambda nr, tp, td, up:
                (tp['result-code'] == 429) and up[0](nr, tp, up[1], up[2]))
    testmetric = nr.metric(mID)
    for i in range(n):
        try:
            v = testmetric.write(1, **wargs)
        except numerous.NumerousMetricConflictError:
            v = "NoChange"
        q.put(v)

apiKey = numerous.numerousKey(None)
nrMain = numerous.Numerous(apiKey=apiKey)

testmetric = nrMain.metric(args.metric)

testmetric.write(0)

if args.testtype == "ADD":
    wargs = { 'add' : True }
else:
    wargs = { 'onlyIf' : True }

outputQ = queue.Queue()

# create the threads...
theThreads = []
for i in range(args.parallel):
    nToWrite = args.nwrites//args.parallel
    # account for residue, some threads will write 1 extra
    if i < (args.nwrites%args.parallel):
        nToWrite += 1

    threadArgs = (apiKey, testmetric.id, nToWrite, wargs, outputQ)
    theThreads.append(threading.Thread(target=tester, args=threadArgs))

# start all the threads...
for t in theThreads:
    t.start()

# wait for all the threads
for t in theThreads:
    t.join()

# print all the results
while True:
    try:
        print(outputQ.get(block=False))
    except queue.Empty:
        break

exit(0)

EOF


# report how much API quota is available, for infotainment purposes.
# Note that we turn off the Numerous class API throttling so we can
# query the server (make one API call) and get a result without ourselves
# being subject to rate throttling...

getAPIQuota() {
  TPGM="
import numerous
remain = -1
refresh = -1
nr = numerous.Numerous(apiKey=\"$APIKEY\", throttle=lambda nr,tp,td,up: False)
try:
    nr.ping()
    remain=nr.statistics['rate-remaining']
    refresh=nr.statistics['rate-reset']
except numerous.NumerousError as x:
    if x.code in (429,500,504): # we are in overloaded condition already
        remain = 0              # report that as zero
        refresh=nr.statistics['rate-reset']
    else:
        raise                   # anything else, not sure what is going on, reraise it

print('{} {}'.format(remain, refresh))
"
  $PYTHON -c "$TPGM"
}




# clever hack to ensure we have at least $1 + $2 API quota remaining
# (or sleep until we get fresh allocation). This is used before
# the atomicity tests to ensure they won't be foiled (slowed down)
# by rate throttling when their entire point is to hammer the server
ensureAPIQuota() {
  if [ "x$2" = "x" ]
  then
    EXTRA=0
  else
    EXTRA=$2
  fi

  NEEDED=`$PYTHON -c "print( $1 + $EXTRA )"`
  infomsg "Ensuring at least $NEEDED API quota available..."
  getAPIQuota >$TMPFILE
  HAVE=`awk '{print $1}' $TMPFILE`
  REFRESH=`awk '{print $2}' $TMPFILE`

  if [ $HAVE -lt $NEEDED ]
  then
    if [ $REFRESH -lt 1 ]; then REFRESH=66; fi
    infomsg " ... Delaying $REFRESH seconds for new API quota, only have $HAVE."
    sleep $REFRESH
  else
    infomsg " ... Have $HAVE API quota; no delay required."
  fi
}


# for bailing out with a message
failout() {
    DIE=yes
    if [ "x$1" = "xCONTINUE" ]; then DIE=no; shift; fi
    echo "$FAIL_PREFIX" "$@"
    if [ "$DIE" = "yes" ]; then exit 1; fi
    infomsg " ... but CONTINUING anyway"
}


#
# idiomatic way to do something with $NR, log it, check for status, etc.
# If $1 looks like "EXIT:N" then the expected result is $? = N
#
# Will exit 1 if fails, otherwise RESULT is set to the result.
#
doNR() {
  GOODSTATUS=0
  case "x$1" in
    xEXIT:*)
      GOODSTATUS=`echo $1 | sed -e 's/^.*://'`
      shift
      ;;
  esac

  if [ "x$NR500" = "x" ]     # XXX just to make the output pretty (no extra space) ...
  then
    echo "$TEST_PREFIX" "$NR $@"
  else
    echo "$TEST_PREFIX" "$NR $NR500 $@"
  fi

  $NR $NR500 "$@" > $TMPFILE
  STATUS=$?
  if [ $STATUS != $GOODSTATUS ]; then failout "... $NR exit status $STATUS"; fi
  RESULT=`cat $TMPFILE`
}

#
# idiomatic way to doNR and test result for a specific result
# Expected result is $1 ; Detail info for unexpected is $2;
# Remaining arguments go to doNR
#
# special syntax for $1:
#  CONTINUE means this doesn't die for failure (just notes it)
#  SOMECONTINUE means this doesn't die depending on the -C flag
#  CONTAINS means instead of requiring an exact match "just contains" works
#
#  You can combine, e.g., verifyNR CONTINUE CONTAINS blah blah blah
#
#
verifyNR() {
  DIE=yes
  CONTAINS=no
  while :
  do
    case "x$1" in
      xCONTINUE)
        DIE=no
        shift
        ;;

      xSOMECONTINUE)
        if [ $SOMECONTINUE = "yes" ]
        then
          DIE="no"
        fi
        shift
        ;;
      xCONTAINS)
        CONTAINS=yes
        shift
        ;;
      x*)
        break
        ;;
    esac
  done

  EXPECTED=$1
  ERRMSG=$2
  shift 2

  doNR "$@"
  GOTIT=no
  if [ $CONTAINS = yes ]
  then
    echo " " "$RESULT" | grep -q -e "$EXPECTED"
    if [ $? -eq 0 ]
    then
      GOTIT=yes
    fi
  elif [ "x$RESULT" = "x$EXPECTED" ]
  then
    GOTIT=yes
  fi

  if [ $GOTIT = "no" ]
  then
    if [ $DIE = "no" ]
    then
      failout CONTINUE "${ERRMSG}: Expected \"$EXPECTED\" Got \"$RESULT\""
    else
      failout "${ERRMSG}: Expected \"$EXPECTED\" Got \"$RESULT\""
    fi
  fi
}

doPython() {
  echo "$TEST_PREFIX" "$PYTHON -c [ ... $1 ]"
  $PYTHON -c "$2" > $TMPFILE
  if [ $? -ne 0 ]; then failout "non-zero exit from python"; fi
  RESULT=`cat $TMPFILE`
}

verifyPython() {
  doPython "$1" "$3"
  if [ "x$RESULT" != "x$2" ]; then failout "expected: $2, got $RESULT"; fi
}

#
# Just a way to put an info into the output stream, properly formatted
#
infomsg() {
  echo "$INFO_PREFIX" "$@"
}

# variant for things skipped via -Q
quickmsg() {
  echo "$QUIK_PREFIX" "$@"
}

# utility function to parse a JSON object and return (via RESULT) a field
# JSON object in $1
# desired field key in $2
parsejson() {
  JPGM="import json; d = json.loads('"$1"'); print(d['"$2"'])"
  RESULT=`$PYTHON -c "$JPGM"`
}

#
# utility function to...
#   Take the JSON object in $1 which should be NR output
#   Go into the Results top level field
#   take the $2'th element of the Results array
#   take the result element of that
#   return the $3 element of that
#
# typical use if you expected one JSON result from NR would be
#
#    parseNRJSON "$J" 0 description
#
# where J is the NR output and, for example, description is the field you want
#
parseNRJSON() {
  JPGM="import json
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('j')
args = parser.parse_args()

d = json.loads(args.j)
print(d['Results']["$2"]['result']['"$3"'])
"

  RESULT=`$PYTHON -c "$JPGM" "$1"`
}

# unsubscribe entirely from the specified metric ID $1
unsubscribe_metric() {
    UPGM="import numerous
nr = numerous.Numerous(apiKey=\"$APIKEY\")
metric = nr.metric($DQ$1$DQ)
# just notificationsEnabled by itself should have been enough
# but timer metrics seem to need notifyWhenBelowSet too ... might
# be a server bug. There seems to be a timing issue at work with that too.
# In any case, turning both off works...
sb = { 'notificationsEnabled' : False, 'notifyWhenBelowSet' : False }
metric.subscribe(sb)
"

# we have a nr command for this now so ... we no longer do this:
#    verifyPython "unsubscribing from metric $1" "" "$UPGM"
# instead do this:
    verifyNR "" "Unsubscribing from $1" --delete -Bq "$1"
}


####### THIS IS WHERE THE TESTING BEGINS ########

#
# Test the -k function first of all
#

if [ "x$NUMEROUSAPIKEY" = x ]
then
  NUMEROUSAPIKEY=$HOME/.myCred export NUMEROUSAPIKEY
fi

infomsg "Version under test:" `$NR -V`

# just to get a more human-friendly error message handle the -k manually
$NR -k > $TMPFILE
if [ $? -ne 0 ]; then failout "Unable to get apikey. Check NUMEROUSAPIKEY."; fi
APIKEY=`cat $TMPFILE`


# XXX because of the "InsecurePlatformWarning" cruft in older
#     versions of python ... see if we are going to have that
#     problem and if so ... warn about it once and then put
#     the appropriate "ignore" into the environment to squelch it

WARNINGSFILE=${TMPFILE}.xxwarnxx
$PYTHON -c "import numerous; x = numerous.Numerous().user()" 2> $WARNINGSFILE
grep -q Insecure $WARNINGSFILE
if [ $? -eq 0 ]
then
  infomsg "Got the InsecurePlatform warning; python needs to be upgraded"
  infomsg "The full warning text is: "
  infomsg " : : : : : : "
  cat $WARNINGSFILE
  infomsg " : : : : : : "
  infomsg "Suppressing warnings during this run"
  PYTHONWARNINGS=ignore export PYTHONWARNINGS
fi
rm -f $WARNINGSFILE


#
# See if we can successfully connect
#
infomsg "Contacting server to verify apikey is valid."
doNR -q

#
# Create a test metric to bang on
#
M=nrTEST$$
MVAL=999
Mparams="{ \"private\" : true, \"value\" : $MVAL }"


doNR -wM +$M private
METRIC=$RESULT

DELETE_THESE="$DELETE_THESE $METRIC"

doNR -w $METRIC $MVAL

# see if it got created with the correct privacy and value
verifyNR $MVAL "Wrong initial value" $METRIC
verifyNR True "Wrong private setting" $METRIC[private]

# see if we can read it with the other allowed metric ID forms
doNR $METRIC'[self]'
verifyNR $MVAL "Reading via $RESULT" $RESULT

doNR $METRIC'[web]'
verifyNR $MVAL "Reading via $RESULT" $RESULT

doNR $METRIC'[embed]'
verifyNR $MVAL "Reading via $RESULT" $RESULT

# test the "set the value naked" method of metric creation
doNR -wM +$M 777
M777=$RESULT
verifyNR 777 "Checking 777 value" $M777

# don't need this metric hanging around
doNR --killmetric $M777

# testing a variety of other ID forms we need to use python to get at them
infomsg "Testing a variety of ID forms in nr.metric() constructor"
for ID in \
  "$METRIC" \
  "{ 'metricId' : $METRIC }" \
  "{ 'metricId' : $DQ$METRIC$DQ }" \
  "{ 'id' : $METRIC }" \
  "{ 'id' : $DQ$METRIC$DQ }" \
  "{ 'metricId' : $DQ$METRIC$DQ, 'id' : 'BOGUS' }"
do

  TPGM="import numerous
nr = numerous.Numerous(apiKey=\"$APIKEY\")
i = $ID
print(nr.metric(i).read())
"

  verifyPython "id: $ID" $MVAL "$TPGM"
done

# testing the exception cases
  TPGM="import numerous
nr = numerous.Numerous(apiKey=\"$APIKEY\")
i = {}
try:
  print(nr.metric(i).read())
  exit(1)
except numerous.NumerousError:
  print('NumerousError')
  exit(0)
"
verifyPython "id: {}" "NumerousError" "$TPGM"

  TPGM="import numerous
nr = numerous.Numerous(apiKey=\"$APIKEY\")
i = {'id' : 'something bogus'}
try:
  print(nr.metric(i).read())
  exit(1)
except numerous.NumerousError as x:
  print('NumerousError {}'.format(x.code))
  exit(0)
"
verifyPython "id: {'id' : 'something bogus'}" "NumerousError 400" "$TPGM"

# try the default constructor
TPGM="import numerous; numerous.NumerousMetric($DQ$METRIC$DQ).write(123456)"
verifyPython "direct NumerousMetric constructor" "" "$TPGM"
verifyNR 123456 "expected 123456" $METRIC

#
# create a second metric that has an identical name, so we can
# test the failure mode of -n
#

infomsg "testing -n and -N duplicate exception cases"
doNR -wq $METRIC $MVAL       # reset value to known
doNR -wM +$M "$Mparams"
DUPMETRIC=$RESULT

doNR EXIT:1 -nq $M
infomsg "::AS EXPECTED:: $RESULT"

doNR EXIT:1 -Nq $M
infomsg "::AS EXPECTED:: $RESULT"

doNR -q --killmetric $DUPMETRIC

# make another one that is similar (prefix)
doNR -wM +${M}x "$Mparams"
DUPMETRIC=$RESULT

verifyNR $MVAL "expected $MVAL" -n $M
doNR EXIT:1 -Nq $M
infomsg "::AS EXPECTED:: $RESULT"
doNR -q --killmetric $DUPMETRIC

# write a value
WVAL=$$
verifyNR $$ "wrong write result" -w $METRIC $WVAL

# write same value with -y and expect exit 1
# NOTE: You can't use quiet mode with -y or else the NoChange is exit 0
verifyNR "NoChange" "-wy" "EXIT:1" -wy $METRIC $WVAL

# testing onlyIf=IGNORE ... there is no shell command for this so:
TPGM="import numerous
nr = numerous.Numerous(apiKey=\"$APIKEY\")
print (nr.metric(\"$METRIC\").write($WVAL, onlyIf='IGNORE'))
"
verifyPython "onlyIf='IGNORE'" $WVAL "$TPGM"

# you really shouldn't do dictionary=True with 'IGNORE', but test it anyway :)
TPGM="import numerous
nr = numerous.Numerous(apiKey=\"$APIKEY\")
print (nr.metric(\"$METRIC\").write($WVAL, onlyIf='IGNORE', dictionary=True)['unchanged'])
"
verifyPython "onlyIf='IGNORE', dictionary=True" True "$TPGM"


# interject a comment
C='this be the naked comment'
doNR -wIq $METRIC "$C"
verifyNR "$C" "Comment readback" -I --limit 1 "$METRIC[commentBody]"

# AGAIN write the same value with -y, should "fail"
verifyNR "NoChange" "-wy" "EXIT:1" -wy $METRIC $$

# increment by 1
doNR $METRIC
NEWVAL=$(($RESULT + 1))
verifyNR $NEWVAL "Added 1" -w+ $METRIC 1

# now writing the original test value with -y should succeed
verifyNR $$ "Rewriting $$" -wy $METRIC $$

# see if the add really works correctly...
verifyNR 17 "Writing 17" -w $METRIC 17
verifyNR 20 "Adding 3" -w+ $METRIC 3
verifyNR -1 "Subtracting 21" -w+ $METRIC -21
verifyNR -1 "Read back" $METRIC

# test event lookup by event ID and by timestamp
V1=33
V2=55
V3=77

verifyNR $V1 "Writing $V1" -w $METRIC $V1
doNR -E --limit 1 "${METRIC}[id]"
V1_ID=$RESULT
doNR -E --limit 1 "${METRIC}[updated]"
V1_UPD=$RESULT

verifyNR $V2 "Writing $V2" -w $METRIC $V2
doNR -E --limit 1 "${METRIC}[id]"
V2_ID=$RESULT
doNR -E --limit 1 "${METRIC}[updated]"
V2_UPD=$RESULT

verifyNR $V3 "Writing $V3" -w $METRIC $V3
doNR -E --limit 1 "${METRIC}[id]"
V3_ID=$RESULT
doNR -E --limit 1 "${METRIC}[updated]"
V3_UPD=$RESULT

# read back each of V1, V2, V3 using id
verifyNR $V1 "Reading $METRIC/$V1_ID" -E $METRIC/$V1_ID'[value]'
verifyNR $V2 "Reading $METRIC/$V2_ID" -E $METRIC/$V2_ID'[value]'
verifyNR $V3 "Reading $METRIC/$V3_ID" -E $METRIC/$V3_ID'[value]'

# and timestamps
verifyNR $V1 "Reading $METRIC/$V1_UPD" -E $METRIC/$V1_UPD'[value]'
verifyNR $V2 "Reading $METRIC/$V2_UPD" -E $METRIC/$V2_UPD'[value]'
verifyNR $V3 "Reading $METRIC/$V3_UPD" -E $METRIC/$V3_UPD'[value]'


# test some of the [] and __x__ semantics
TPGM="import numerous
nr = numerous.Numerous(apiKey=\"$APIKEY\")
m = nr.metric($DQ$METRIC$DQ)

val = 88
m.write(val)
for k in m:             # __iter__
  if k == 'value':
    if m[k] != val:     # __getitem__
      exit(1)

if 'value' not in m:    # __contains__
  exit(1)

if m['label'] not in str(m):   # __str__ .. a little hokey as a test
  exit(1)

exit(0)
"
verifyPython "testing __x__ funcs and []" "" "$TPGM"

# a couple of quick tests of subscription functions
# inspired by old (now-fixed) bugs
                              # by name without -n, on purpose to test error
verifyNR "" "-B exception" EXIT:1 -Bq $M
verifyNR "False" "Checking notifyOnAnyChange" -B "${METRIC}[notifyOnAnyChange]"

# this isn't really a "test" so much as it is just an exercise...
# The "Numerous Users" metric has a lot of subscribers, or at least it usually
# does ... so try to access it and read all the subscribers and just report
# some general statistics. There is forgiveness in this test because we
# don't even necessarily know that that metric will live on forever...
XXNU=6019025553067790305   # we "just know" this is the metric
doNR $XXNU'[label]'
if [ "$RESULT" != "Numerous Users" ]
then
  infomsg "Metric $XXNU wasn't exactly the expected Numerous Users metric"
  infomsg "Check the metric and/or this test code. Skipping tests on $XXNU"
else
  TPGM="import numerous
nr = numerous.Numerous(apiKey=\"$APIKEY\")
m = nr.metric($DQ$XXNU$DQ)
s = [ x for x in m.subscriptions() ]
print('{} {}'.format(len(s), nr.statistics['serverRequests']))
"
  doPython "counting subscribers" "$TPGM"
  N=`echo $RESULT | awk '{print $1}'`
  RQ=`echo $RESULT | awk '{print $2}'`
  infomsg "Found $N subscribers; it took $RQ server calls to get them"
fi

# test on a totally separate metric to test out the 'updated' write() feature

TPGM="import numerous

nr = numerous.Numerous(apiKey=\"$APIKEY\")
metric = nr.createMetric(\"nrTXX$$\", attrs={ 'private' : True })

testval = 99
r = metric.write(testval, dictionary=True)
ids = { testval : r['id'] }

# write some values from the past
testvector = [ 55, 44, 88, 66, 33 ]
testvectormax = 88 # XXX we just know this

for i in testvector:
  tstr = '2001-01-01T10:00:01.0{}Z'.format(i)
  r = metric.write(i, updated=tstr, dictionary=True)
  ids[i] = r['id']

# since all those were from earlier than the testval, value should be testval
if metric.read() != testval:
  exit(1)

# delete the testval we wrote, leaving the timestamped values only
metric.eventDelete(ids[testval])

# it should be whatever is the max in the test vector now
if metric.read() != testvectormax:
  exit(1)

metric.crushKillDestroy()
exit(0)
"

verifyPython "testing \"updated\" timestamp feature in write()" "" "$TPGM"

# before making an error entry turn off error notifications on the metric
unsubscribe_metric $METRIC

# try making an error entry
ErrString="This is the error info"
ErrInfo="{ \"kind\": \"error\", \"commentBody\": \"$ErrString\" }"

verifyNR "" "Setting an error" -wIq $METRIC "$ErrInfo"

# see if that error is actually there now
verifyNR "error" "Reading back [kind] via interactions" -I --limit 1 "$METRIC[kind]"
verifyNR "error" "Reading back [kind] via stream" -S --limit 1 "$METRIC[kind]"

# and check the text using both the interactions and the stream
verifyNR CONTINUE "$ErrString" "Readback errstring via interactions" -I --limit 1 "$METRIC[commentBody]"
verifyNR "$ErrString" "Readback errstring w -S" -S --limit 1 "$METRIC[commentBody]"

# test updating a metric's description
Desc="This is the metric's porpoise in life"
Units="blivets"
updateJSON="{ \"description\": \"$Desc\", \"units\" : \"$Units\" }"

doNR -wMq $METRIC "$updateJSON"
verifyNR "$Desc" "[description]" "${METRIC}[description]"
verifyNR "$Units" "[units]" "${METRIC}[units]"

# once more to check read/mod/write feature
Desc="something else"
updateJSON="{ \"description\": \"$Desc\" }"
doNR -wMq $METRIC "$updateJSON"
verifyNR "$Desc" "[description(2)]" "${METRIC}[description]"
verifyNR "$Units" "[units(2)]" "${METRIC}[units]"

# some JSON option testing (testing the nr command itself)
V=123
doNR -wq $METRIC $V
doNR -j $METRIC $METRIC $METRIC
J="$RESULT"
for i in 0 1 2
do
  parseNRJSON "$J" $i value
  if [ "x$RESULT" != "x$V" ]
  then
    failout "Got $RESULT expected $V for element $i"
  fi
done

Desc="{ a bunch of stuff in unbalanced] braces {}"
updateJSON="{ \"description\": \"$Desc\" }"

doNR -wMq $METRIC "$updateJSON"
doNR -j $METRIC
J="$RESULT"
parseNRJSON "$J" 0 description
if [ "x$RESULT" != "x$Desc" ]
then
  failout "Got $RESULT expected $Desc"
fi

# make a "timer" metric to bang on
TMR=nrTMRTEST$$
TMRparams='{ "private" : true, "kind" : "timer" }'

doNR -wM +$TMR "$TMRparams"
TMETRIC=$RESULT
DELETE_THESE="$DELETE_THESE $TMETRIC"

unsubscribe_metric $TMETRIC     # otherwise you might get pinged during test


# set it to a particular date

doNR -wq $TMETRIC "EPOCHTIME: 1/15/2011"   # nephew's birthday :)

# XXX timezones make testing this harder than I want to worry about
# XXX so instead what I'm going to do is set it to another date 24
# XXX hours later, and assume that if the difference between the two
# XXX values is, in fact, 24 hours, that it "worked".
doNR $TMETRIC
T0="$RESULT"

# set it to 1 day later than that
doNR -wq $TMETRIC "EPOCHTIME: 1/16/2011"
doNR $TMETRIC
T1="$RESULT"
TPGM="print('{:.1f}'.format($T1 - $T0))"
verifyPython "Checking timestamps are 24 hours apart" "86400.0" "$TPGM"

# another date test .. there was a bug that only showed up on dates
# in the future (it was obscure!) so do one of those
doNR -wq $TMETRIC "EPOCHTIME: 1/15/2050"
doNR $TMETRIC
T0="$RESULT"
doNR -wq $TMETRIC "EPOCHTIME: 1/16/2050"
doNR $TMETRIC
T1="$RESULT"
verifyPython "Checking future timestamps are 24 hours apart" "86400.0" "$TPGM"

# try setting it to now
doNR -w $TMETRIC "EPOCHTIME:now"
TMNOW="$RESULT"

# this python program will output the number of seconds between "now"
# and the metric value we just set ... that should be fairly small
TPGM="import time

print(int(time.time() - $TMNOW))
"
doPython "checking EPOCHTIME:now value" "$TPGM"

# above one minute difference we're definitely calling a failure
# NOTE: don't run these tests on a machine so loaded down this fails (duh)
if [ $RESULT -gt 60 ]
then
    failout "Difference between EPOCHTIME:now and now is too large"
elif [ $RESULT -gt 5 ]
then
    infomsg "Difference between EPOCHTIME:now and now is $RESULT"
fi

# make another "virgin" metric to bang on
VGM=nrVGTEST$$
VGMparams='{ "private" : true }'

doNR -wM +$VGM "$VGMparams"
VGMETRIC=$RESULT

DELETE_THESE="$DELETE_THESE $VGMETRIC"

# make sure getting an empty collection of various flavors works
for ARG in E I S
do
  verifyNR "" "-${ARG}" -${ARG} $VGMETRIC
done


# fire off 100 add +1 operations in parallel.
# They are supposed to operate atomically (they didn't in the past
# but that was a server bug and is now fixed)

if [ $QUICK = yes ]
then
  quickmsg "Skipping atomicity test."
else
  NADD=100
  ensureAPIQuota $NADD 25
  infomsg "Atomicity test. $NADD ADD +1 in parallel"
  $PYTHON $ATOMICTESTPROGRAM -n $NADD -m $METRIC -p 10 ADD > $TMPFILE
  verifyNR SOMECONTINUE $NADD "Atomicity failed" $METRIC
fi

# fire off a bunch of "onlyIfChanged" operations in parallel
# only one of them should change the variable, the rest should be "NoChange"
#
# XXX the server does implement these atomically, so I've never been
#     able to verify whether this would expose any atomicity error.

# another version of the numerous server atomicity test
yatom() {

    NTIMES=100
    ensureAPIQuota $NTIMES 25
    $PYTHON $ATOMICTESTPROGRAM -n $NTIMES -p 10 -m "$METRIC" ONLY > $TMPFILE

    # There should be NTIMES - 1 "NoChange" entries and only one that changed it
    X=`grep NoChange $TMPFILE | wc -l`
    if [ $X -ne `$PYTHON -c "print($NTIMES - 1)"` ]
    then
      Y=`$PYTHON -c "print($NTIMES - $X)"`
      echo "The onlyIfChanged operation is not atomic. It changed $Y times."
      echo "Details of log file follow: - - - - - - - - - -"
      cat $TMPFILE
      echo "end of log file - - - - - - - - -"
      EXITSTATUS=1
    fi
}

if [ $QUICK = no ]
then
  infomsg "many parallel onlyIfChanged updates - atomicity test"
  yatom
else
  quickmsg "Skipping test of parallel onlyIf updates"
fi

rm -f $ATOMICTESTPROGRAM

# TEST like ...
doNR -wIq $METRIC '{ "kind": "like" }'

# see if the Like is actually there now
verifyNR "like" "[kind]" -I --limit 1 "$METRIC[kind]"


#
# Make some value events, then test to see if deleting them works
#
VSQ1=17
VSQ2=42
VSQ3=62
VSQ4=69
VSQ5=666


# this is a brain dead way to do it but copy/paste was better than
# engineering some shell array hack or relying on bash

infomsg "event deletion... first making events"
doNR -wq $METRIC $VSQ1
doNR -S --limit 1 "${METRIC}[id]"
VID1=$RESULT

doNR -wq $METRIC $VSQ2
doNR -S --limit 1 "${METRIC}[id]"
VID2=$RESULT

doNR -wq $METRIC $VSQ3
doNR -S --limit 1 "${METRIC}[id]"
VID3=$RESULT

doNR -wq $METRIC $VSQ4
doNR -S --limit 1 "${METRIC}[id]"
VID4=$RESULT

doNR -wq $METRIC $VSQ5
doNR -S --limit 1 "${METRIC}[id]"
VID5=$RESULT

verifyNR "$VSQ5" "5th value" $METRIC

doNR --delete -E -q $METRIC $VID4

verifyNR "$VSQ5" "5th value after deleting 4th" $METRIC

# now when we delete VID5 the value should become #3 bcs we deleted 4
doNR --delete -E -q $METRIC $VID5

verifyNR "$VSQ3" "3rd value after deleting 4th and 5th" $METRIC

# delete #4 again should get error
verifyNR "" "re-delete #4" "EXIT:1" --delete -E -q $METRIC $VID4

# testing --delete on interactions
# make a comment
infomsg "interaction deletion... first making interactions"
CMT="THIS IS THE COMMENT FOR WHICH WE ARE LOOKING"
doNR -wIq $METRIC "$CMT"

verifyNR "$CMT" "comment readback" -I --limit 1 "$METRIC[commentBody]"

doNR -I --limit 1 "${METRIC}[id]"
CMTID="$RESULT"

doNR --delete -Iq $METRIC $CMTID

# now the magic comment shouldn't be in there anywhere
infomsg "grepping stream output to ensure comment is gone..."
$NR -S $METRIC | grep -q "$CMT"
if [ $? = 0 ]
then
  failout "the designated comment is still visible in the stream"
fi
infomsg "It is gone! (yay!)"


# PERMISSIONS TESTING
infomsg "TESTING FINE-GRAINED PERMISSIONS"

# get our user ID
doNR -Uj
UJ="$RESULT"
parsejson "$UJ" id
USERID_ME="$RESULT"
parsejson "$UJ" userName
USERNAME_ME="$RESULT"
infomsg "My user ID is $USERID_ME (userName: $USERNAME_ME)"

# set the test metric to visibility private, which enables fine-grained perms
doNR -wMq $METRIC '{ "visibility" : "private" }'

# permissions collection should be just the default (all perms) for us
verifyNR "$USERID_ME on $METRIC: readMetric updateValue editPermissions editMetric " "permissions collection" -A $METRIC

# if we have an alternate ID try that out.
# First off the alternate ID should not be able to read it right now
# because we set visibility private and have not established perms
if [ "x$NUMEROUSAPIKEY2" = x ]
then
    infomsg "SKIPPING some permission tests because no second APIKey given."
    infomsg " ... please set environment variable NUMEROUSAPIKEY2 to enable."
else
    K2=$NUMEROUSAPIKEY2       # just for brevity

    # Set metric to a known value
    V="86753"
    doNR -wq $METRIC "$V"

    # find out secondary user ID
    doNR -Uj -c "$K2"
    UJ="$RESULT"
    parsejson "$UJ" id
    USERID_2="$RESULT"
    parsejson "$UJ" userName
    USERNAME_2="$RESULT"
    infomsg "Secondary user ID is $USERID_2 (userName: $USERNAME_2)"

    # try reading metric as unpermitted secondary user
    verifyNR CONTAINS 403 "reading forbidden metric" EXIT:1 -j -c "$K2" $METRIC

    # try a few other ways to access it as unpermitted secondary user
    verifyNR CONTAINS 403 "stream from forbidden metric" EXIT:1 -Sj -c "$K2" $METRIC

    verifyNR CONTAINS 403 "events from forbidden metric" EXIT:1 -Ej -c "$K2" $METRIC

    verifyNR CONTAINS 403 "interactions from forbidden metric" EXIT:1 -Ij -c "$K2" $METRIC

    # XXX I was going to test "shouldn't able to like/comment/error" but
    #     as of 4/14/2015 you CAN do those things even on a private metric
    #     and even with no permissions at all. So I'm not sure if that
    #     is a server bug or functions-as-designed.


    # now give K2 read permission
    doNR -wAq ${METRIC}/${USERID_2} '{ "readMetric": true }'

    verifyNR "$V" "reading back as $USERID_2" -c "$K2" $METRIC

    # writing it as secondary user should fail
    doNR EXIT:1 -wq -c "$K2" $METRIC 12345
    doNR EXIT:1 -wq+ -c "$K2" $METRIC 12345  # this way too
    doNR EXIT:1 -wqy -c "$K2" $METRIC 12345  # and this way

    # give the secondary user read/write permission
    doNR -wAq ${METRIC}/${USERID_2} '{ "readMetric" : true, "updateValue": true }'

    # try writes again
    verifyNR "888" "writing metric as secondary user" -w -c "$K2" $METRIC 888
    verifyNR "889" "adding to metric as secondary user" -w+ -c "$K2" $METRIC 1

    # the read should still work
    verifyNR "889" "reading yet again" -c "$K2" $METRIC

fi

# testing photos... first make a tiny GIF file (one pixel image)

# this 35 byte GIF file might not be entirely legal; in any case
# the Numerous server transforms it into a slightly longer file on
# readback so we don't use it any more

#GIFDATA="\\x47\\x49\\x46\\x38\\x39\\x61\\x01\\x00\\x01\\x00\\x80\\x00\\x00\\xff\\xff\\xff\\x00\\x00\\x00\\x2c\\x00\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x02\\x02\\x44\\x01\\x00\\x3b"

# This 43 byte GIF file keeps the Numerous server happy
GIFDATA="\\x47\\x49\\x46\\x38\\x39\\x61\\x01\\x00\\x01\\x00\\xf0\\x00\\x00\\xff\\xff\\xff\\x00\\x00\\x00\\x21\\xf9\\x04\\x00\\x00\\x00\\x00\\x00\\x2c\\x00\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x02\\x02\\x44\\x01\\x00\\x3b"

GIFFILE=/tmp/g$$.gif
GIFFILE2=/tmp/g2$$.gif

GIFPGM="s = \"${GIFDATA}\"
f = open(\"$GIFFILE\", \"wb\")
f.write(b\"$GIFDATA\")
f.close()
"

$PYTHON -c "$GIFPGM"

# set the photo
doNR -wPq $METRIC $GIFFILE

# get the URL of the photo
doNR -P $METRIC
PhotoURL="$RESULT"

infomsg "the photoURL is: $PhotoURL"

if [ "x$PhotoURL" = "xNone" ]
then
  # this should never happen
  failout "Bad photo URL ... got None"
else
  # get the photo... we use python/requests because we know we have them
  # vs some platforms having curl and some wget etc. We don't need to test
  # for errors here because ultimately they will be caught by the cmp check

  READPGM="import requests, sys
r = requests.get(sys.stdin.read().strip('\n'))
f = open(\"$GIFFILE2\", \"wb\")
bytes = r.content
f.write(bytes)
f.close()
"
  echo $PhotoURL | $PYTHON -c "$READPGM"

  # When I used the 35-byte image the NumerousApp server didn't read
  # it back (it transformed it into a 43 byte image). I'm guessing that
  # the 35 byte image isn't strictly legal, or at least it omits some
  # things the Numerous server expects to see in there (they are processing
  # images they receive and modifying them before storage)
  #
  # The 43-byte file I am using now appears to be "stable" with respect
  # to that processing. However I've kept the logic in here that does
  # the write-read-write-read and compares the last write/read cycle.
  # It is superfluous now with the 43 byte image however.
  #
  # It turns out that what we CAN do, however, is readback the modified
  # image, then write THAT, then read THAT back again. In that case it
  # comes back unchanged. Obviously this "test" is implementation specific
  # and somewhat tenuous/fragile at this point. So be it. It might be best
  # in the long run to just not try to test data integrity for photo uploads.
  # You know whether it works when you see your results with your eyes...
  #

  # So, first off, report whether the first cycle matches. This is actually
  # superfluous and potentially confusing if you don't understand the
  # above essay. :) ... for that reason failure isn't reported.

  cmp -s $GIFFILE $GIFFILE2
  if [ $? -eq 0 ]; then infomsg "first pass image matches"; fi

  # regardless, proceed with the second-pass method too, just because.

  mv $GIFFILE2 $GIFFILE       # make the file that we just read the "source"

  # this delete isnt necessary but makes us feel better that
  # we're actually testing a write/read-back operation now for sure
  doNR --delete -Pq $METRIC

  # now write the modified (by NumerousApp server) test GIF
  doNR -wPq $METRIC $GIFFILE

  # ... and read THAT one back
  doNR -P $METRIC
  PhotoURL="$RESULT"

  infomsg "the second-pass photoURL is: $PhotoURL"

  if [ "x$PhotoURL" = "xNone" ]
  then
    # this should never happen
    failout "Bad photo URL ... got None"
  else
    echo $PhotoURL | $PYTHON -c "$READPGM"
  fi

  # finally -- compare the photo with what we had set it to be
  cmp -l $GIFFILE $GIFFILE2
  if [ $? != 0 ]
  then
    echo "files do not compare"
    # may as well keep going but note this failure of course
    EXITSTATUS=1
  fi

  # someone once claimed (tweeted) that doing a metric PUT erased photoURL.
  # I think they were confused (I've never seen that bug anyway).
  # We know it erases unspecified parameters (e.g., description) but
  # it isn't supposed to erase photoURL. Test for that.
  doNR "$METRIC[photoURL]"
  PhotoURL="$RESULT"
  TPGM="import numerous
nr = numerous.Numerous(apiKey=\"$APIKEY\")
metric = nr.metric($DQ$METRIC$DQ)
metric.update({'description' : 'blotto'}, overwriteAll=True)
print(metric.read(dictionary=True)['photoURL'])
"
  verifyPython "updating description with overwriteAll" "$PhotoURL" "$TPGM"

  # test photo deletion
  doNR --delete -Pq $METRIC
fi

rm -f $GIFFILE $GIFFILE2

# photo URL should be None now
verifyNR "None" "Expected None for photo URL" -P $METRIC

# final output just print the stream
infomsg "Now just outputting the resulting stream"
doNR -S $METRIC

infomsg "the first 5 lines of that stream..."
infomsg "- * - * - * - * -"
echo "$RESULT" | head -5
infomsg "- * - * - * - * -"

#
# Some tests of throttling functionality
#
if [ $QUICK = no ]
then
  infomsg "Voluntary throttling tests take a few minutes"

  TPGM="import numerous
import time

nr = numerous.Numerous(apiKey=\"$APIKEY\")
metric = nr.metric($DQ$METRIC$DQ)
n = 0

nr.ping()             # just anything to cause an API call
# arbitrary - but we know 30 seconds is usually more than enough window
if nr.statistics['rate-reset'] < 30:
   time.sleep(nr.statistics['rate-reset'])   # wait until top of minute

# Note that the above ping() itself could have throttled...
nT0 = nr.statistics['throttleVoluntaryBackoff']

while nr.statistics['throttleVoluntaryBackoff'] == nT0:
    x = metric.read()
    n += 1
    # shouldn't take anywhere near this many...
    if n > 1000:
        print('Unable to trigger voluntary throttling')
        exit(1)

print('{} {}'.format(n, nr.statistics['throttleVoluntaryDelays']))
exit(0)
"

  doPython "Testing voluntary throttling" "$TPGM"
  CALLS=`echo $RESULT | awk '{print $1}'`
  TIME=`echo $RESULT | awk '{print $2}'`
  infomsg "Voluntary throttle delayed $TIME after $CALLS calls"

  # test the throttle cap; this is a little bit adhoc but if we
  # use up a gazillion APIs at the "top" of the minute, then we
  # should be able to trigger the code path that caps the delay.
  # See equivalent concept in ratetest.py
  TPGM="import numerous
import time

nr = numerous.Numerous(apiKey=\"$APIKEY\")
metric = nr.metric($DQ$METRIC$DQ)

noVol = lambda nr, tp, td, up: (
   (tp['result-code'] == 429) and up[0](nr, tp, up[1], up[2]))
nrX = numerous.Numerous(apiKey=\"$APIKEY\", throttle=noVol)

# get to the top of the minute (fresh API allocation)
# and then get the APIs remaining down to a very small number
ignored = nrX.user()
if nrX.statistics['rate-reset'] > 0:
   time.sleep(nrX.statistics['rate-reset'])

while nrX.statistics['rate-remaining'] > 3:
    ignored = nrX.user()

n = 0
while nr.statistics['throttleVoluntaryBackoff'] == 0:
    x = metric.read()
    n += 1
    # shouldn't take anywhere near this many...
    if n > 1000:
        print('Unable to trigger voluntary throttling')
        exit(1)

# One way or another this delay will happen... may as well just sit here
# (because we've used up almost all the API allocation at this point)
time.sleep(nr.statistics['rate-reset'])

# if everything works right, the throttleVoluntaryDelays statistics should
# be equal to the volmaxdelay buried in the system default throttle policy.
# Check for that. This is obviously very implementation-dependent/aware.
# It is, however and after all, a test program...
#
try:
  sysvmd = nr._Numerous__throttlePolicy[1]['volmaxdelay']
except:
  sysvmd = -1

# print the int times 1000 to make the subsequent shell test easier
print('{} {} {}'.format(n, int(1000*nr.statistics['throttleVoluntaryDelays']), int(1000*sysvmd)))
exit(0)
"

  doPython "Testing voluntary throttling capped case" "$TPGM"
  CALLS=`echo $RESULT | awk '{print $1}'`
  TIME=`echo $RESULT | awk '{print $2}'`
  EXPECTED=`echo $RESULT | awk '{print $3}'`
  if [ "$TIME" -eq "$EXPECTED" ]
  then
    infomsg "Delay was $TIME msec after $CALLS calls, as expected"
  else
    failout CONTINUE "Delay was $TIME msec after $CALLS calls, but expected $EXPECTED"
  fi

  # at the risk of being silly... the voluntary throttling test synchronizes
  # us to a particular part of the rate throttling clock cycle, and on
  # general principles it would be better if we were randomly located within
  # that cycle ... so get randomly located this way...
  TPGM="import random; import time; time.sleep(random.randrange(1,60))"
  doPython "Random delay to desynchronize after throttle test" "$TPGM"

else
  quickmsg "Not testing voluntary throttling"
fi

#
# create 200 comments just to make sure the chunked iterators work
#

if [ $QUICK = no ]
then
  infomsg "testing 200 x $NR -Iwq $METRIC commentNNN"

  CMTS=""
  for i in 0 1
  do
    for j in 0 1 2 3 4 5 6 7 8 9
    do
      CMTS="$CMTS cmt$i${j}0 cmt$i${j}1 cmt$i${j}2 cmt$i${j}3 cmt$i${j}4"
      CMTS="$CMTS cmt$i${j}5 cmt$i${j}6 cmt$i${j}7 cmt$i${j}8 cmt$i${j}9"
      doNR -wIq $METRIC cmt$i${j}0 $METRIC cmt$i${j}1 $METRIC cmt$i${j}2 $METRIC cmt$i${j}3 $METRIC cmt$i${j}4 $METRIC cmt$i${j}5 $METRIC cmt$i${j}6 $METRIC cmt$i${j}7 $METRIC cmt$i${j}8 $METRIC cmt$i${j}9 >/dev/null
      #
      # we shoot one of the comments on purpose to test the test code (!)
      #
      if [ $i = 0 ]
      then
        if [ $j = 3 ]
        then
          infomsg "deleting one of the 200 comments along the way"
          # shoot this comment
          doNR -I --limit 1 "${METRIC}[id]"
          SHOTID=$RESULT
          doNR --delete -I $METRIC $SHOTID
          SHOT="cmt039"     # XXX ugh, but easiest way
        fi
      fi
    done
  done

  infomsg "verifying all those comments were stored correctly"

  #
  # every comment made should be in the stream now...
  # ... except the one comment we shoot on purpose to test the test code!

  $NR -S $METRIC > $TMPFILE

  for m in $CMTS
  do
    grep -q $m $TMPFILE
    if [ $? != 0 ]
    then
      if [ x"$m" != x"$SHOT" ]
      then
        failout CONTINUE "did not find $m in output"
        EXITSTATUS=1
      fi
    else
      # but this one is SUPPOSED to be missing
      if [ x"$m" = x"$SHOT" ]
      then
        failout CONTINUE "still FOUND $m in output after deleting it"
        EXITSTATUS=1
      fi
    fi
  done

  infomsg "ALSO verifying via $NR -I $METRIC  (just interactions)"
  $NR -I $METRIC > $TMPFILE

  for m in $CMTS
  do
    grep -q $m $TMPFILE
    if [ $? != 0 ]
    then
      if [ x"$m" != x"$SHOT" ]
      then
        failout CONTINUE "did not find $m in output"
        EXITSTATUS=1
      fi
    else
      # but this one is SUPPOSED to be missing
      if [ x"$m" = x"$SHOT" ]
      then
        failout CONTINUE "still FOUND $m in output after deleting it"
        EXITSTATUS=1
      fi
    fi
  done
else
  quickmsg "Skipping the creation of a gazillion comments"
fi

#
# This next test makes sure the metrics collection iteration works right
# To test that we have to make a whole lotta variables. So here goes.
#
# This part takes a while so it is skipped if you ask for QUICK mode
#

if [ $QUICK = no ]
then
  N_TO_CREATE=99
  PFX="DELETE-ME-XXX-DELETE-ME-"
  TPGM="
import numerous
nr = numerous.Numerous(apiKey=\"$APIKEY\")
params = { 'private' : True }
for i in range($N_TO_CREATE):
  name=\"$PFX\"+str(i)
  m = nr.createMetric(name, attrs=params)
  print(m['id'])
"
  doPython "creating $N_TO_CREATE metrics" "$TPGM"
  DELETE_THESE="$DELETE_THESE $RESULT"
else
  quickmsg "Skipping the creation/deletion of a gazillion metrics"
fi

# at this point it's a royal pain to exit early, so track it this way
EXITSTATUS=0

#
# Get a list of metrics
#
infomsg "plain $NR to search for all metrics we made"
doNR
echo "$RESULT" > $TMPFILE

#
# every variable we made should be in that output
#
for m in $DELETE_THESE
do
  grep -q $m $TMPFILE
  if [ $? != 0 ]
  then
    failout CONTINUE "did not find $m in output"
    EXITSTATUS=1
  fi
done

#
# Now delete all the variables we created for this test
#
doNR -q --killmetric $DELETE_THESE

rm -f $TMPFILE
exit $EXITSTATUS
